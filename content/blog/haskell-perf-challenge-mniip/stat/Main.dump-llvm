
==================== LLVM Code ====================
2018-10-14 00:18:47.355047832 UTC

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux"


==================== LLVM Code ====================
2018-10-14 00:18:47.355672747 UTC

declare ccc i8* @memcpy$def(i8*, i8*, i64)


==================== LLVM Code ====================
2018-10-14 00:18:47.356144344 UTC

declare ccc i8* @memmove$def(i8*, i8*, i64)


==================== LLVM Code ====================
2018-10-14 00:18:47.356535127 UTC

declare ccc i8* @memset$def(i8*, i64, i64)


==================== LLVM Code ====================
2018-10-14 00:18:47.35691467 UTC

declare ccc i64 @newSpark$def(i8*, i8*)


==================== LLVM Code ====================
2018-10-14 00:18:47.357409183 UTC

!0 = !{!"root"}
!1 = !{!"top", !0}
!2 = !{!"stack", !1}
!3 = !{!"heap", !1}
!4 = !{!"rx", !3}
!5 = !{!"base", !1}


==================== LLVM Code ====================
2018-10-14 00:18:47.358377088 UTC



==================== LLVM Code ====================
2018-10-14 00:18:47.359319204 UTC

%Main_zdtrModule4_bytes_struct = type <{[5 x i8]}>
@Main_zdtrModule4_bytes$def = internal constant %Main_zdtrModule4_bytes_struct<{[5 x i8] [i8 109, i8 97, i8 105, i8 110, i8 0]}>, align 1
@Main_zdtrModule4_bytes = alias i8, bitcast (%Main_zdtrModule4_bytes_struct* @Main_zdtrModule4_bytes$def to i8*)


==================== LLVM Code ====================
2018-10-14 00:18:47.362574647 UTC

%Main_zdtrModule3_closure_struct = type <{i64, i64}>
@Main_zdtrModule3_closure$def = internal global %Main_zdtrModule3_closure_struct<{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TrNameS_con_info to i64), i64 ptrtoint (%Main_zdtrModule4_bytes_struct* @Main_zdtrModule4_bytes$def to i64)}>
@Main_zdtrModule3_closure = alias i8, bitcast (%Main_zdtrModule3_closure_struct* @Main_zdtrModule3_closure$def to i8*)


==================== LLVM Code ====================
2018-10-14 00:18:47.363574699 UTC

%Main_zdtrModule2_bytes_struct = type <{[5 x i8]}>
@Main_zdtrModule2_bytes$def = internal constant %Main_zdtrModule2_bytes_struct<{[5 x i8] [i8 77, i8 97, i8 105, i8 110, i8 0]}>, align 1
@Main_zdtrModule2_bytes = alias i8, bitcast (%Main_zdtrModule2_bytes_struct* @Main_zdtrModule2_bytes$def to i8*)


==================== LLVM Code ====================
2018-10-14 00:18:47.364707814 UTC

%Main_zdtrModule1_closure_struct = type <{i64, i64}>
@Main_zdtrModule1_closure$def = internal global %Main_zdtrModule1_closure_struct<{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TrNameS_con_info to i64), i64 ptrtoint (%Main_zdtrModule2_bytes_struct* @Main_zdtrModule2_bytes$def to i64)}>
@Main_zdtrModule1_closure = alias i8, bitcast (%Main_zdtrModule1_closure_struct* @Main_zdtrModule1_closure$def to i8*)


==================== LLVM Code ====================
2018-10-14 00:18:47.365854691 UTC

%Main_zdtrModule_closure_struct = type <{i64, i64, i64, i64}>
@Main_zdtrModule_closure$def = internal global %Main_zdtrModule_closure_struct<{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_Module_con_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule3_closure_struct* @Main_zdtrModule3_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%Main_zdtrModule1_closure_struct* @Main_zdtrModule1_closure$def to i64),i64 1), i64 3}>
@Main_zdtrModule_closure = alias i8, bitcast (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i8*)


==================== LLVM Code ====================
2018-10-14 00:18:47.406306342 UTC

%Main_mainzuzdszdwsievefn_closure_struct = type <{i64}>
@Main_mainzuzdszdwsievefn_closure$def = internal global %Main_mainzuzdszdwsievefn_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_mainzuzdszdwsievefn_info$def to i64)}>
@Main_mainzuzdszdwsievefn_closure = alias i8, bitcast (%Main_mainzuzdszdwsievefn_closure_struct* @Main_mainzuzdszdwsievefn_closure$def to i8*)


==================== LLVM Code ====================
2018-10-14 00:18:47.408010444 UTC

@Main_mainzuzdszdwsievefn_slow = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_mainzuzdszdwsievefn_slow$def to i8*)
define ghccc void @Main_mainzuzdszdwsievefn_slow$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind
{
c8lJ:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %ln8tN = load i64*, i64** %Sp_Var
  %ln8tO = getelementptr inbounds i64, i64* %ln8tN, i32 4
  %ln8tP = bitcast i64* %ln8tO to i64*
  %ln8tQ = load i64, i64* %ln8tP, !tbaa !2
  store i64 %ln8tQ, i64* %R6_Var
  %ln8tR = load i64*, i64** %Sp_Var
  %ln8tS = getelementptr inbounds i64, i64* %ln8tR, i32 3
  %ln8tT = bitcast i64* %ln8tS to i64*
  %ln8tU = load i64, i64* %ln8tT, !tbaa !2
  store i64 %ln8tU, i64* %R5_Var
  %ln8tV = load i64*, i64** %Sp_Var
  %ln8tW = getelementptr inbounds i64, i64* %ln8tV, i32 2
  %ln8tX = bitcast i64* %ln8tW to i64*
  %ln8tY = load i64, i64* %ln8tX, !tbaa !2
  store i64 %ln8tY, i64* %R4_Var
  %ln8tZ = load i64*, i64** %Sp_Var
  %ln8u0 = getelementptr inbounds i64, i64* %ln8tZ, i32 1
  %ln8u1 = bitcast i64* %ln8u0 to i64*
  %ln8u2 = load i64, i64* %ln8u1, !tbaa !2
  store i64 %ln8u2, i64* %R3_Var
  %ln8u3 = load i64*, i64** %Sp_Var
  %ln8u4 = getelementptr inbounds i64, i64* %ln8u3, i32 0
  %ln8u5 = bitcast i64* %ln8u4 to i64*
  %ln8u6 = load i64, i64* %ln8u5, !tbaa !2
  store i64 %ln8u6, i64* %R2_Var
  %ln8u7 = load i64, i64* %R1_Var
  store i64 %ln8u7, i64* %R1_Var
  %ln8u8 = load i64*, i64** %Sp_Var
  %ln8u9 = getelementptr inbounds i64, i64* %ln8u8, i32 5
  %ln8ua = ptrtoint i64* %ln8u9 to i64
  %ln8ub = inttoptr i64 %ln8ua to i64*
  store i64* %ln8ub, i64** %Sp_Var
  %ln8uc = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_mainzuzdszdwsievefn_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8ud = load i64*, i64** %Sp_Var
  %ln8ue = load i64, i64* %R1_Var
  %ln8uf = load i64, i64* %R2_Var
  %ln8ug = load i64, i64* %R3_Var
  %ln8uh = load i64, i64* %R4_Var
  %ln8ui = load i64, i64* %R5_Var
  %ln8uj = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8uc( i64* %Base_Arg, i64* %ln8ud, i64* %Hp_Arg, i64 %ln8ue, i64 %ln8uf, i64 %ln8ug, i64 %ln8uh, i64 %ln8ui, i64 %ln8uj, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.413866572 UTC

@s8iS_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @s8iS_info$def to i8*)
define internal ghccc void @s8iS_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i64}><{i64 8589934596, i64 12884901889, i64 8}>
{
c8mW:
  %ls8iT = alloca i64, i32 1
  %ls8iS = alloca i64, i32 1
  %ls8iq = alloca i64, i32 1
  %ls8io = alloca i64, i32 1
  %ls8iQ = alloca i64, i32 1
  %ls8iW = alloca i64, i32 1
  %ls8j0 = alloca i64, i32 1
  %ls8j1 = alloca i64, i32 1
  %ls8jd = alloca i64, i32 1
  %ls8jh = alloca i64, i32 1
  %ls8ji = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  store i64 %R2_Arg, i64* %ls8iT
  %ln8uk = load i64, i64* %R1_Var
  store i64 %ln8uk, i64* %ls8iS
  br label %c8mO
c8mO:
  %ln8ul = load i64, i64* %ls8iS
  %ln8um = add i64 %ln8ul, 6
  %ln8un = inttoptr i64 %ln8um to i64*
  %ln8uo = load i64, i64* %ln8un, !tbaa !1
  store i64 %ln8uo, i64* %ls8iq
  %ln8up = load i64, i64* %ls8iS
  %ln8uq = add i64 %ln8up, 14
  %ln8ur = inttoptr i64 %ln8uq to i64*
  %ln8us = load i64, i64* %ln8ur, !tbaa !1
  store i64 %ln8us, i64* %ls8io
  %ln8ut = load i64, i64* %ls8iT
  %ln8uu = load i64, i64* %ls8iS
  %ln8uv = add i64 %ln8uu, 30
  %ln8uw = inttoptr i64 %ln8uv to i64*
  %ln8ux = load i64, i64* %ln8uw, !tbaa !1
  %ln8uy = icmp slt i64 %ln8ut, %ln8ux
  %ln8uz = zext i1 %ln8uy to i64
  switch i64 %ln8uz, label %c8mU [i64 1, label %c8mV]
c8mU:
  %ln8uA = load i64, i64* %ls8iS
  %ln8uB = add i64 %ln8uA, 22
  %ln8uC = inttoptr i64 %ln8uB to i64*
  %ln8uD = load i64, i64* %ln8uC, !tbaa !1
  store i64 %ln8uD, i64* %ls8iQ
  %ln8uE = load i64, i64* %ls8iT
  %ln8uF = ashr i64 %ln8uE, 3
  store i64 %ln8uF, i64* %ls8iW
  %ln8uG = load i64, i64* %ls8iq
  %ln8uH = add i64 %ln8uG, 16
  %ln8uI = load i64, i64* %ls8io
  %ln8uJ = load i64, i64* %ls8iW
  %ln8uK = add i64 %ln8uI, %ln8uJ
  %ln8uL = add i64 %ln8uH, %ln8uK
  %ln8uM = inttoptr i64 %ln8uL to i8*
  %ln8uN = load i8, i8* %ln8uM, !tbaa !1
  %ln8uO = zext i8 %ln8uN to i64
  store i64 %ln8uO, i64* %ls8j0
  %ln8uP = load i64, i64* %ls8iT
  %ln8uQ = and i64 %ln8uP, 7
  store i64 %ln8uQ, i64* %ls8j1
  %ln8uR = load i64, i64* %ls8j1
  %ln8uS = icmp sge i64 %ln8uR, 64
  %ln8uT = zext i1 %ln8uS to i64
  switch i64 %ln8uT, label %c8nc [i64 1, label %c8nd]
c8nc:
  %ln8uU = load i64, i64* %ls8iq
  %ln8uV = add i64 %ln8uU, 16
  %ln8uW = load i64, i64* %ls8io
  %ln8uX = load i64, i64* %ls8iW
  %ln8uY = add i64 %ln8uW, %ln8uX
  %ln8uZ = add i64 %ln8uV, %ln8uY
  %ln8v0 = load i64, i64* %ls8j0
  %ln8v1 = load i64, i64* %ls8j1
  %ln8v2 = shl i64 1, %ln8v1
  %ln8v3 = trunc i64 %ln8v2 to i8
  %ln8v4 = zext i8 %ln8v3 to i64
  %ln8v5 = or i64 %ln8v0, %ln8v4
  %ln8v6 = trunc i64 %ln8v5 to i8
  %ln8v7 = inttoptr i64 %ln8uZ to i8*
  store i8 %ln8v6, i8* %ln8v7, !tbaa !1
  %ln8v8 = load i64, i64* %ls8iT
  %ln8v9 = load i64, i64* %ls8iQ
  %ln8va = add i64 %ln8v8, %ln8v9
  store i64 %ln8va, i64* %ls8iT
  br label %c8mO
c8nd:
  %ln8vb = load i64, i64* %ls8iq
  %ln8vc = add i64 %ln8vb, 16
  %ln8vd = load i64, i64* %ls8io
  %ln8ve = load i64, i64* %ls8iW
  %ln8vf = add i64 %ln8vd, %ln8ve
  %ln8vg = add i64 %ln8vc, %ln8vf
  %ln8vh = load i64, i64* %ls8j0
  %ln8vi = trunc i64 %ln8vh to i8
  %ln8vj = inttoptr i64 %ln8vg to i8*
  store i8 %ln8vi, i8* %ln8vj, !tbaa !1
  %ln8vk = load i64, i64* %ls8iT
  %ln8vl = load i64, i64* %ls8iQ
  %ln8vm = add i64 %ln8vk, %ln8vl
  store i64 %ln8vm, i64* %ls8iT
  br label %c8mO
c8mV:
  %ln8vn = load i64, i64* %ls8iT
  %ln8vo = ashr i64 %ln8vn, 3
  store i64 %ln8vo, i64* %ls8jd
  %ln8vp = load i64, i64* %ls8iq
  %ln8vq = add i64 %ln8vp, 16
  %ln8vr = load i64, i64* %ls8io
  %ln8vs = load i64, i64* %ls8jd
  %ln8vt = add i64 %ln8vr, %ln8vs
  %ln8vu = add i64 %ln8vq, %ln8vt
  %ln8vv = inttoptr i64 %ln8vu to i8*
  %ln8vw = load i8, i8* %ln8vv, !tbaa !1
  %ln8vx = zext i8 %ln8vw to i64
  store i64 %ln8vx, i64* %ls8jh
  %ln8vy = load i64, i64* %ls8iT
  %ln8vz = and i64 %ln8vy, 7
  store i64 %ln8vz, i64* %ls8ji
  %ln8vA = load i64, i64* %ls8ji
  %ln8vB = icmp sge i64 %ln8vA, 64
  %ln8vC = zext i1 %ln8vB to i64
  switch i64 %ln8vC, label %c8nr [i64 1, label %c8ns]
c8nr:
  %ln8vD = load i64, i64* %ls8iq
  %ln8vE = add i64 %ln8vD, 16
  %ln8vF = load i64, i64* %ls8io
  %ln8vG = load i64, i64* %ls8jd
  %ln8vH = add i64 %ln8vF, %ln8vG
  %ln8vI = add i64 %ln8vE, %ln8vH
  %ln8vJ = load i64, i64* %ls8jh
  %ln8vK = load i64, i64* %ls8ji
  %ln8vL = shl i64 1, %ln8vK
  %ln8vM = trunc i64 %ln8vL to i8
  %ln8vN = zext i8 %ln8vM to i64
  %ln8vO = or i64 %ln8vJ, %ln8vN
  %ln8vP = trunc i64 %ln8vO to i8
  %ln8vQ = inttoptr i64 %ln8vI to i8*
  store i8 %ln8vP, i8* %ln8vQ, !tbaa !1
  %ln8vR = ptrtoint i8* @ghczmprim_GHCziTuple_Z0T_closure to i64
  %ln8vS = add i64 %ln8vR, 1
  store i64 %ln8vS, i64* %R1_Var
  %ln8vT = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  %ln8vU = bitcast i64* %ln8vT to i64*
  %ln8vV = load i64, i64* %ln8vU, !tbaa !2
  %ln8vW = inttoptr i64 %ln8vV to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8vX = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8vW( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %ln8vX, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
c8ns:
  %ln8vY = load i64, i64* %ls8iq
  %ln8vZ = add i64 %ln8vY, 16
  %ln8w0 = load i64, i64* %ls8io
  %ln8w1 = load i64, i64* %ls8jd
  %ln8w2 = add i64 %ln8w0, %ln8w1
  %ln8w3 = add i64 %ln8vZ, %ln8w2
  %ln8w4 = load i64, i64* %ls8jh
  %ln8w5 = trunc i64 %ln8w4 to i8
  %ln8w6 = inttoptr i64 %ln8w3 to i8*
  store i8 %ln8w5, i8* %ln8w6, !tbaa !1
  %ln8w7 = ptrtoint i8* @ghczmprim_GHCziTuple_Z0T_closure to i64
  %ln8w8 = add i64 %ln8w7, 1
  store i64 %ln8w8, i64* %R1_Var
  %ln8w9 = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  %ln8wa = bitcast i64* %ln8w9 to i64*
  %ln8wb = load i64, i64* %ln8wa, !tbaa !2
  %ln8wc = inttoptr i64 %ln8wb to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8wd = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8wc( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %ln8wd, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.421347287 UTC

@s8kg_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @s8kg_info$def to i8*)
define internal ghccc void @s8kg_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i64}><{i64 8589934596, i64 12884901889, i64 8}>
{
c8oy:
  %ls8kh = alloca i64, i32 1
  %ls8kg = alloca i64, i32 1
  %ls8iq = alloca i64, i32 1
  %ls8io = alloca i64, i32 1
  %ls8ke = alloca i64, i32 1
  %ls8kk = alloca i64, i32 1
  %ls8ko = alloca i64, i32 1
  %ls8kp = alloca i64, i32 1
  %ls8kB = alloca i64, i32 1
  %ls8kF = alloca i64, i32 1
  %ls8kG = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  store i64 %R2_Arg, i64* %ls8kh
  %ln8we = load i64, i64* %R1_Var
  store i64 %ln8we, i64* %ls8kg
  br label %c8oq
c8oq:
  %ln8wf = load i64, i64* %ls8kg
  %ln8wg = add i64 %ln8wf, 6
  %ln8wh = inttoptr i64 %ln8wg to i64*
  %ln8wi = load i64, i64* %ln8wh, !tbaa !1
  store i64 %ln8wi, i64* %ls8iq
  %ln8wj = load i64, i64* %ls8kg
  %ln8wk = add i64 %ln8wj, 14
  %ln8wl = inttoptr i64 %ln8wk to i64*
  %ln8wm = load i64, i64* %ln8wl, !tbaa !1
  store i64 %ln8wm, i64* %ls8io
  %ln8wn = load i64, i64* %ls8kh
  %ln8wo = load i64, i64* %ls8kg
  %ln8wp = add i64 %ln8wo, 30
  %ln8wq = inttoptr i64 %ln8wp to i64*
  %ln8wr = load i64, i64* %ln8wq, !tbaa !1
  %ln8ws = icmp sgt i64 %ln8wn, %ln8wr
  %ln8wt = zext i1 %ln8ws to i64
  switch i64 %ln8wt, label %c8ow [i64 1, label %c8ox]
c8ow:
  %ln8wu = load i64, i64* %ls8kg
  %ln8wv = add i64 %ln8wu, 22
  %ln8ww = inttoptr i64 %ln8wv to i64*
  %ln8wx = load i64, i64* %ln8ww, !tbaa !1
  store i64 %ln8wx, i64* %ls8ke
  %ln8wy = load i64, i64* %ls8kh
  %ln8wz = ashr i64 %ln8wy, 3
  store i64 %ln8wz, i64* %ls8kk
  %ln8wA = load i64, i64* %ls8iq
  %ln8wB = add i64 %ln8wA, 16
  %ln8wC = load i64, i64* %ls8io
  %ln8wD = load i64, i64* %ls8kk
  %ln8wE = add i64 %ln8wC, %ln8wD
  %ln8wF = add i64 %ln8wB, %ln8wE
  %ln8wG = inttoptr i64 %ln8wF to i8*
  %ln8wH = load i8, i8* %ln8wG, !tbaa !1
  %ln8wI = zext i8 %ln8wH to i64
  store i64 %ln8wI, i64* %ls8ko
  %ln8wJ = load i64, i64* %ls8kh
  %ln8wK = and i64 %ln8wJ, 7
  store i64 %ln8wK, i64* %ls8kp
  %ln8wL = load i64, i64* %ls8kp
  %ln8wM = icmp sge i64 %ln8wL, 64
  %ln8wN = zext i1 %ln8wM to i64
  switch i64 %ln8wN, label %c8oO [i64 1, label %c8oP]
c8oO:
  %ln8wO = load i64, i64* %ls8iq
  %ln8wP = add i64 %ln8wO, 16
  %ln8wQ = load i64, i64* %ls8io
  %ln8wR = load i64, i64* %ls8kk
  %ln8wS = add i64 %ln8wQ, %ln8wR
  %ln8wT = add i64 %ln8wP, %ln8wS
  %ln8wU = load i64, i64* %ls8ko
  %ln8wV = load i64, i64* %ls8kp
  %ln8wW = shl i64 1, %ln8wV
  %ln8wX = trunc i64 %ln8wW to i8
  %ln8wY = zext i8 %ln8wX to i64
  %ln8wZ = or i64 %ln8wU, %ln8wY
  %ln8x0 = trunc i64 %ln8wZ to i8
  %ln8x1 = inttoptr i64 %ln8wT to i8*
  store i8 %ln8x0, i8* %ln8x1, !tbaa !1
  %ln8x2 = load i64, i64* %ls8kh
  %ln8x3 = load i64, i64* %ls8ke
  %ln8x4 = add i64 %ln8x2, %ln8x3
  store i64 %ln8x4, i64* %ls8kh
  br label %c8oq
c8oP:
  %ln8x5 = load i64, i64* %ls8iq
  %ln8x6 = add i64 %ln8x5, 16
  %ln8x7 = load i64, i64* %ls8io
  %ln8x8 = load i64, i64* %ls8kk
  %ln8x9 = add i64 %ln8x7, %ln8x8
  %ln8xa = add i64 %ln8x6, %ln8x9
  %ln8xb = load i64, i64* %ls8ko
  %ln8xc = trunc i64 %ln8xb to i8
  %ln8xd = inttoptr i64 %ln8xa to i8*
  store i8 %ln8xc, i8* %ln8xd, !tbaa !1
  %ln8xe = load i64, i64* %ls8kh
  %ln8xf = load i64, i64* %ls8ke
  %ln8xg = add i64 %ln8xe, %ln8xf
  store i64 %ln8xg, i64* %ls8kh
  br label %c8oq
c8ox:
  %ln8xh = load i64, i64* %ls8kh
  %ln8xi = ashr i64 %ln8xh, 3
  store i64 %ln8xi, i64* %ls8kB
  %ln8xj = load i64, i64* %ls8iq
  %ln8xk = add i64 %ln8xj, 16
  %ln8xl = load i64, i64* %ls8io
  %ln8xm = load i64, i64* %ls8kB
  %ln8xn = add i64 %ln8xl, %ln8xm
  %ln8xo = add i64 %ln8xk, %ln8xn
  %ln8xp = inttoptr i64 %ln8xo to i8*
  %ln8xq = load i8, i8* %ln8xp, !tbaa !1
  %ln8xr = zext i8 %ln8xq to i64
  store i64 %ln8xr, i64* %ls8kF
  %ln8xs = load i64, i64* %ls8kh
  %ln8xt = and i64 %ln8xs, 7
  store i64 %ln8xt, i64* %ls8kG
  %ln8xu = load i64, i64* %ls8kG
  %ln8xv = icmp sge i64 %ln8xu, 64
  %ln8xw = zext i1 %ln8xv to i64
  switch i64 %ln8xw, label %c8p3 [i64 1, label %c8p4]
c8p3:
  %ln8xx = load i64, i64* %ls8iq
  %ln8xy = add i64 %ln8xx, 16
  %ln8xz = load i64, i64* %ls8io
  %ln8xA = load i64, i64* %ls8kB
  %ln8xB = add i64 %ln8xz, %ln8xA
  %ln8xC = add i64 %ln8xy, %ln8xB
  %ln8xD = load i64, i64* %ls8kF
  %ln8xE = load i64, i64* %ls8kG
  %ln8xF = shl i64 1, %ln8xE
  %ln8xG = trunc i64 %ln8xF to i8
  %ln8xH = zext i8 %ln8xG to i64
  %ln8xI = or i64 %ln8xD, %ln8xH
  %ln8xJ = trunc i64 %ln8xI to i8
  %ln8xK = inttoptr i64 %ln8xC to i8*
  store i8 %ln8xJ, i8* %ln8xK, !tbaa !1
  %ln8xL = ptrtoint i8* @ghczmprim_GHCziTuple_Z0T_closure to i64
  %ln8xM = add i64 %ln8xL, 1
  store i64 %ln8xM, i64* %R1_Var
  %ln8xN = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  %ln8xO = bitcast i64* %ln8xN to i64*
  %ln8xP = load i64, i64* %ln8xO, !tbaa !2
  %ln8xQ = inttoptr i64 %ln8xP to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8xR = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8xQ( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %ln8xR, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
c8p4:
  %ln8xS = load i64, i64* %ls8iq
  %ln8xT = add i64 %ln8xS, 16
  %ln8xU = load i64, i64* %ls8io
  %ln8xV = load i64, i64* %ls8kB
  %ln8xW = add i64 %ln8xU, %ln8xV
  %ln8xX = add i64 %ln8xT, %ln8xW
  %ln8xY = load i64, i64* %ls8kF
  %ln8xZ = trunc i64 %ln8xY to i8
  %ln8y0 = inttoptr i64 %ln8xX to i8*
  store i8 %ln8xZ, i8* %ln8y0, !tbaa !1
  %ln8y1 = ptrtoint i8* @ghczmprim_GHCziTuple_Z0T_closure to i64
  %ln8y2 = add i64 %ln8y1, 1
  store i64 %ln8y2, i64* %R1_Var
  %ln8y3 = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  %ln8y4 = bitcast i64* %ln8y3 to i64*
  %ln8y5 = load i64, i64* %ln8y4, !tbaa !2
  %ln8y6 = inttoptr i64 %ln8y5 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8y7 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8y6( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %ln8y7, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.428980839 UTC

@Main_mainzuzdszdwsievefn_info = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_mainzuzdszdwsievefn_info$def to i8*)
define ghccc void @Main_mainzuzdszdwsievefn_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i64, i64, i64, i64}><{i64 add (i64 sub (i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_mainzuzdszdwsievefn_slow$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_mainzuzdszdwsievefn_info$def to i64)),i64 0), i64 965, i64 0, i64 30064771072, i64 0, i64 14}>
{
c8pK:
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %ln8y8 = load i64*, i64** %Sp_Var
  %ln8y9 = getelementptr inbounds i64, i64* %ln8y8, i32 -6
  %ln8ya = ptrtoint i64* %ln8y9 to i64
  %ln8yb = icmp ult i64 %ln8ya, %SpLim_Arg
  %ln8yd = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %ln8yb, i1 0 )
  br i1 %ln8yd, label %u8tj, label %u8ti
u8ti:
  %ln8ye = load i64*, i64** %Sp_Var
  %ln8yf = getelementptr inbounds i64, i64* %ln8ye, i32 -5
  store i64 %R2_Arg, i64* %ln8yf, !tbaa !2
  %ln8yg = load i64*, i64** %Sp_Var
  %ln8yh = getelementptr inbounds i64, i64* %ln8yg, i32 -4
  store i64 %R3_Arg, i64* %ln8yh, !tbaa !2
  %ln8yi = load i64*, i64** %Sp_Var
  %ln8yj = getelementptr inbounds i64, i64* %ln8yi, i32 -3
  store i64 %R4_Arg, i64* %ln8yj, !tbaa !2
  %ln8yk = load i64*, i64** %Sp_Var
  %ln8yl = getelementptr inbounds i64, i64* %ln8yk, i32 -2
  store i64 %R5_Arg, i64* %ln8yl, !tbaa !2
  %ln8ym = load i64*, i64** %Sp_Var
  %ln8yn = getelementptr inbounds i64, i64* %ln8ym, i32 -1
  store i64 %R6_Arg, i64* %ln8yn, !tbaa !2
  %ln8yo = load i64*, i64** %Sp_Var
  %ln8yp = getelementptr inbounds i64, i64* %ln8yo, i32 -5
  %ln8yq = ptrtoint i64* %ln8yp to i64
  %ln8yr = inttoptr i64 %ln8yq to i64*
  store i64* %ln8yr, i64** %Sp_Var
  %ln8ys = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_c8lK$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8yt = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8ys( i64* %Base_Arg, i64* %ln8yt, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
u8tj:
  %ln8yu = load i64*, i64** %Sp_Var
  %ln8yv = getelementptr inbounds i64, i64* %ln8yu, i32 -5
  store i64 %R2_Arg, i64* %ln8yv, !tbaa !2
  %ln8yw = load i64*, i64** %Sp_Var
  %ln8yx = getelementptr inbounds i64, i64* %ln8yw, i32 -4
  store i64 %R3_Arg, i64* %ln8yx, !tbaa !2
  %ln8yy = load i64*, i64** %Sp_Var
  %ln8yz = getelementptr inbounds i64, i64* %ln8yy, i32 -3
  store i64 %R4_Arg, i64* %ln8yz, !tbaa !2
  %ln8yA = load i64*, i64** %Sp_Var
  %ln8yB = getelementptr inbounds i64, i64* %ln8yA, i32 -2
  store i64 %R5_Arg, i64* %ln8yB, !tbaa !2
  %ln8yC = load i64*, i64** %Sp_Var
  %ln8yD = getelementptr inbounds i64, i64* %ln8yC, i32 -1
  store i64 %R6_Arg, i64* %ln8yD, !tbaa !2
  %ln8yE = load i64*, i64** %Sp_Var
  %ln8yF = getelementptr inbounds i64, i64* %ln8yE, i32 -5
  %ln8yG = ptrtoint i64* %ln8yF to i64
  %ln8yH = inttoptr i64 %ln8yG to i64*
  store i64* %ln8yH, i64** %Sp_Var
  %ln8yI = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_c8pL$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8yJ = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8yI( i64* %Base_Arg, i64* %ln8yJ, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}
declare ccc i1 @llvm.expect.i1(i1, i1)


==================== LLVM Code ====================
2018-10-14 00:18:47.436141126 UTC

@_c8lK = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_c8lK$def to i8*)
define internal ghccc void @_c8lK$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind
{
c8lK:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %ls8im = alloca i64, i32 1
  %ls8in = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %ls8io = alloca i64, i32 1
  %ls8ip = alloca i64, i32 1
  %ls8iq = alloca i64, i32 1
  %ls8ix = alloca i64, i32 1
  %ls8iy = alloca i64, i32 1
  %ls8iA = alloca i64, i32 1
  %ls8iD = alloca i64, i32 1
  %ln8yK = load i64*, i64** %Hp_Var
  %ln8yL = getelementptr inbounds i64, i64* %ln8yK, i32 2
  %ln8yM = ptrtoint i64* %ln8yL to i64
  %ln8yN = inttoptr i64 %ln8yM to i64*
  store i64* %ln8yN, i64** %Hp_Var
  %ln8yO = load i64*, i64** %Hp_Var
  %ln8yP = ptrtoint i64* %ln8yO to i64
  %ln8yQ = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %ln8yR = bitcast i64* %ln8yQ to i64*
  %ln8yS = load i64, i64* %ln8yR, !tbaa !5
  %ln8yT = icmp ugt i64 %ln8yP, %ln8yS
  %ln8yU = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %ln8yT, i1 0 )
  br i1 %ln8yU, label %c8pO, label %c8pN
c8pN:
  %ln8yV = load i64*, i64** %Sp_Var
  %ln8yW = getelementptr inbounds i64, i64* %ln8yV, i32 0
  %ln8yX = bitcast i64* %ln8yW to i64*
  %ln8yY = load i64, i64* %ln8yX, !tbaa !2
  store i64 %ln8yY, i64* %ls8im
  %ln8yZ = load i64*, i64** %Sp_Var
  %ln8z0 = getelementptr inbounds i64, i64* %ln8yZ, i32 1
  %ln8z1 = bitcast i64* %ln8z0 to i64*
  %ln8z2 = load i64, i64* %ln8z1, !tbaa !2
  store i64 %ln8z2, i64* %ls8in
  %ln8z3 = load i64, i64* %ls8im
  %ln8z4 = icmp slt i64 %ln8z3, 100000000
  %ln8z5 = zext i1 %ln8z4 to i64
  switch i64 %ln8z5, label %c8pI [i64 1, label %c8pJ]
c8pI:
  %ln8z7 = ptrtoint i8* @ghczmprim_GHCziTypes_Izh_con_info to i64
  %ln8z6 = load i64*, i64** %Hp_Var
  %ln8z8 = getelementptr inbounds i64, i64* %ln8z6, i32 -1
  store i64 %ln8z7, i64* %ln8z8, !tbaa !3
  %ln8za = load i64, i64* %ls8in
  %ln8z9 = load i64*, i64** %Hp_Var
  %ln8zb = getelementptr inbounds i64, i64* %ln8z9, i32 0
  store i64 %ln8za, i64* %ln8zb, !tbaa !3
  %ln8zd = load i64*, i64** %Hp_Var
  %ln8ze = ptrtoint i64* %ln8zd to i64
  %ln8zf = add i64 %ln8ze, -7
  store i64 %ln8zf, i64* %R1_Var
  %ln8zg = load i64*, i64** %Sp_Var
  %ln8zh = getelementptr inbounds i64, i64* %ln8zg, i32 5
  %ln8zi = ptrtoint i64* %ln8zh to i64
  %ln8zj = inttoptr i64 %ln8zi to i64*
  store i64* %ln8zj, i64** %Sp_Var
  %ln8zk = load i64*, i64** %Sp_Var
  %ln8zl = getelementptr inbounds i64, i64* %ln8zk, i32 0
  %ln8zm = bitcast i64* %ln8zl to i64*
  %ln8zn = load i64, i64* %ln8zm, !tbaa !2
  %ln8zo = inttoptr i64 %ln8zn to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8zp = load i64*, i64** %Sp_Var
  %ln8zq = load i64*, i64** %Hp_Var
  %ln8zr = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8zo( i64* %Base_Arg, i64* %ln8zp, i64* %ln8zq, i64 %ln8zr, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
c8pJ:
  %ln8zs = load i64*, i64** %Sp_Var
  %ln8zt = getelementptr inbounds i64, i64* %ln8zs, i32 2
  %ln8zu = bitcast i64* %ln8zt to i64*
  %ln8zv = load i64, i64* %ln8zu, !tbaa !2
  store i64 %ln8zv, i64* %ls8io
  %ln8zw = load i64*, i64** %Sp_Var
  %ln8zx = getelementptr inbounds i64, i64* %ln8zw, i32 3
  %ln8zy = bitcast i64* %ln8zx to i64*
  %ln8zz = load i64, i64* %ln8zy, !tbaa !2
  store i64 %ln8zz, i64* %ls8ip
  %ln8zA = load i64*, i64** %Sp_Var
  %ln8zB = getelementptr inbounds i64, i64* %ln8zA, i32 4
  %ln8zC = bitcast i64* %ln8zB to i64*
  %ln8zD = load i64, i64* %ln8zC, !tbaa !2
  store i64 %ln8zD, i64* %ls8iq
  %ln8zE = load i64, i64* %ls8iq
  %ln8zF = add i64 %ln8zE, 16
  %ln8zG = load i64, i64* %ls8io
  %ln8zH = load i64, i64* %ls8im
  %ln8zI = ashr i64 %ln8zH, 3
  %ln8zJ = add i64 %ln8zG, %ln8zI
  %ln8zK = add i64 %ln8zF, %ln8zJ
  %ln8zL = inttoptr i64 %ln8zK to i8*
  %ln8zM = load i8, i8* %ln8zL, !tbaa !1
  %ln8zN = zext i8 %ln8zM to i64
  store i64 %ln8zN, i64* %ls8ix
  %ln8zO = load i64, i64* %ls8im
  %ln8zP = and i64 %ln8zO, 7
  store i64 %ln8zP, i64* %ls8iy
  %ln8zQ = load i64, i64* %ls8iy
  %ln8zR = icmp sge i64 %ln8zQ, 64
  %ln8zS = zext i1 %ln8zR to i64
  switch i64 %ln8zS, label %c8rT [i64 1, label %c8rU]
c8rT:
  %ln8zT = load i64*, i64** %Hp_Var
  %ln8zU = getelementptr inbounds i64, i64* %ln8zT, i32 -2
  %ln8zV = ptrtoint i64* %ln8zU to i64
  %ln8zW = inttoptr i64 %ln8zV to i64*
  store i64* %ln8zW, i64** %Hp_Var
  %ln8zX = load i64, i64* %ls8iy
  %ln8zY = shl i64 1, %ln8zX
  store i64 %ln8zY, i64* %ls8iA
  br label %s8iz
s8iz:
  %ln8zZ = load i64, i64* %ls8ix
  %ln8A0 = load i64, i64* %ls8iA
  %ln8A1 = trunc i64 %ln8A0 to i8
  %ln8A2 = zext i8 %ln8A1 to i64
  %ln8A3 = and i64 %ln8zZ, %ln8A2
  store i64 %ln8A3, i64* %ls8iD
  %ln8A4 = load i64, i64* %ls8iD
  switch i64 %ln8A4, label %c8pT [i64 0, label %u8tk]
c8pT:
  %ln8A6 = load i64, i64* %ls8im
  %ln8A7 = add i64 %ln8A6, 1
  %ln8A5 = load i64*, i64** %Sp_Var
  %ln8A8 = getelementptr inbounds i64, i64* %ln8A5, i32 0
  store i64 %ln8A7, i64* %ln8A8, !tbaa !2
  %ln8Aa = load i64, i64* %ls8in
  %ln8A9 = load i64*, i64** %Sp_Var
  %ln8Ab = getelementptr inbounds i64, i64* %ln8A9, i32 1
  store i64 %ln8Aa, i64* %ln8Ab, !tbaa !2
  %ln8Ad = load i64, i64* %ls8io
  %ln8Ac = load i64*, i64** %Sp_Var
  %ln8Ae = getelementptr inbounds i64, i64* %ln8Ac, i32 2
  store i64 %ln8Ad, i64* %ln8Ae, !tbaa !2
  %ln8Ag = load i64, i64* %ls8ip
  %ln8Af = load i64*, i64** %Sp_Var
  %ln8Ah = getelementptr inbounds i64, i64* %ln8Af, i32 3
  store i64 %ln8Ag, i64* %ln8Ah, !tbaa !2
  %ln8Aj = load i64, i64* %ls8iq
  %ln8Ai = load i64*, i64** %Sp_Var
  %ln8Ak = getelementptr inbounds i64, i64* %ln8Ai, i32 4
  store i64 %ln8Aj, i64* %ln8Ak, !tbaa !2
  %ln8Al = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_c8lK$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8Am = load i64*, i64** %Sp_Var
  %ln8An = load i64*, i64** %Hp_Var
  %ln8Ao = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8Al( i64* %Base_Arg, i64* %ln8Am, i64* %ln8An, i64 %ln8Ao, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
u8tk:
  %ln8Aq = load i64, i64* %ls8iD
  %ln8Ap = load i64*, i64** %Sp_Var
  %ln8Ar = getelementptr inbounds i64, i64* %ln8Ap, i32 -1
  store i64 %ln8Aq, i64* %ln8Ar, !tbaa !2
  %ln8As = load i64*, i64** %Sp_Var
  %ln8At = getelementptr inbounds i64, i64* %ln8As, i32 -1
  %ln8Au = ptrtoint i64* %ln8At to i64
  %ln8Av = inttoptr i64 %ln8Au to i64*
  store i64* %ln8Av, i64** %Sp_Var
  %ln8Aw = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_c8mg$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8Ax = load i64*, i64** %Sp_Var
  %ln8Ay = load i64*, i64** %Hp_Var
  %ln8Az = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8Aw( i64* %Base_Arg, i64* %ln8Ax, i64* %ln8Ay, i64 %ln8Az, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
c8rU:
  %ln8AA = load i64*, i64** %Hp_Var
  %ln8AB = getelementptr inbounds i64, i64* %ln8AA, i32 -2
  %ln8AC = ptrtoint i64* %ln8AB to i64
  %ln8AD = inttoptr i64 %ln8AC to i64*
  store i64* %ln8AD, i64** %Hp_Var
  store i64 0, i64* %ls8iA
  br label %s8iz
c8pO:
  %ln8AE = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 16, i64* %ln8AE, !tbaa !5
  %ln8AF = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_c8pL$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8AG = load i64*, i64** %Sp_Var
  %ln8AH = load i64*, i64** %Hp_Var
  %ln8AI = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8AF( i64* %Base_Arg, i64* %ln8AG, i64* %ln8AH, i64 %ln8AI, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.443187083 UTC

@_c8pL = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_c8pL$def to i8*)
define internal ghccc void @_c8pL$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind
{
c8pL:
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %ln8AJ = ptrtoint %Main_mainzuzdszdwsievefn_closure_struct* @Main_mainzuzdszdwsievefn_closure$def to i64
  store i64 %ln8AJ, i64* %R1_Var
  %ln8AK = getelementptr inbounds i64, i64* %Base_Arg, i32 -1
  %ln8AL = bitcast i64* %ln8AK to i64*
  %ln8AM = load i64, i64* %ln8AL, !tbaa !5
  %ln8AN = inttoptr i64 %ln8AM to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8AO = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8AN( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %ln8AO, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.457325031 UTC

@_c8mg = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_c8mg$def to i8*)
define internal ghccc void @_c8mg$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind
{
c8mg:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %ls8im = alloca i64, i32 1
  %ls8in = alloca i64, i32 1
  %ls8io = alloca i64, i32 1
  %ls8ip = alloca i64, i32 1
  %ls8iq = alloca i64, i32 1
  %ls8iF = alloca i64, i32 1
  %ls8iG = alloca i64, i32 1
  %ls8iK = alloca i64, i32 1
  %ls8iO = alloca i64, i32 1
  %ls8iQ = alloca i64, i32 1
  %ls8iP = alloca i64, i32 1
  %lc8mM = alloca i64, i32 1
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %ls8jM = alloca i64, i32 1
  %ls8jQ = alloca i64, i32 1
  %ls8jR = alloca i64, i32 1
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %ls8k8 = alloca i64, i32 1
  %ls8kc = alloca i64, i32 1
  %ls8ke = alloca i64, i32 1
  %ls8kd = alloca i64, i32 1
  %lc8oo = alloca i64, i32 1
  %ls8la = alloca i64, i32 1
  %ls8le = alloca i64, i32 1
  %ls8lf = alloca i64, i32 1
  %ls8iD = alloca i64, i32 1
  %ln8AP = load i64*, i64** %Hp_Var
  %ln8AQ = getelementptr inbounds i64, i64* %ln8AP, i32 5
  %ln8AR = ptrtoint i64* %ln8AQ to i64
  %ln8AS = inttoptr i64 %ln8AR to i64*
  store i64* %ln8AS, i64** %Hp_Var
  %ln8AT = load i64*, i64** %Hp_Var
  %ln8AU = ptrtoint i64* %ln8AT to i64
  %ln8AV = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %ln8AW = bitcast i64* %ln8AV to i64*
  %ln8AX = load i64, i64* %ln8AW, !tbaa !5
  %ln8AY = icmp ugt i64 %ln8AU, %ln8AX
  %ln8AZ = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %ln8AY, i1 0 )
  br i1 %ln8AZ, label %c8q0, label %c8pZ
c8pZ:
  %ln8B0 = load i64*, i64** %Sp_Var
  %ln8B1 = getelementptr inbounds i64, i64* %ln8B0, i32 1
  %ln8B2 = bitcast i64* %ln8B1 to i64*
  %ln8B3 = load i64, i64* %ln8B2, !tbaa !2
  store i64 %ln8B3, i64* %ls8im
  %ln8B4 = load i64*, i64** %Sp_Var
  %ln8B5 = getelementptr inbounds i64, i64* %ln8B4, i32 2
  %ln8B6 = bitcast i64* %ln8B5 to i64*
  %ln8B7 = load i64, i64* %ln8B6, !tbaa !2
  store i64 %ln8B7, i64* %ls8in
  %ln8B8 = load i64*, i64** %Sp_Var
  %ln8B9 = getelementptr inbounds i64, i64* %ln8B8, i32 3
  %ln8Ba = bitcast i64* %ln8B9 to i64*
  %ln8Bb = load i64, i64* %ln8Ba, !tbaa !2
  store i64 %ln8Bb, i64* %ls8io
  %ln8Bc = load i64*, i64** %Sp_Var
  %ln8Bd = getelementptr inbounds i64, i64* %ln8Bc, i32 4
  %ln8Be = bitcast i64* %ln8Bd to i64*
  %ln8Bf = load i64, i64* %ln8Be, !tbaa !2
  store i64 %ln8Bf, i64* %ls8ip
  %ln8Bg = load i64*, i64** %Sp_Var
  %ln8Bh = getelementptr inbounds i64, i64* %ln8Bg, i32 5
  %ln8Bi = bitcast i64* %ln8Bh to i64*
  %ln8Bj = load i64, i64* %ln8Bi, !tbaa !2
  store i64 %ln8Bj, i64* %ls8iq
  %ln8Bk = load i64, i64* %ls8im
  %ln8Bl = load i64, i64* %ls8im
  %ln8Bm = mul i64 %ln8Bk, %ln8Bl
  store i64 %ln8Bm, i64* %ls8iF
  %ln8Bn = load i64, i64* %ls8im
  %ln8Bo = load i64, i64* %ls8im
  %ln8Bp = mul i64 %ln8Bn, %ln8Bo
  %ln8Bq = load i64, i64* %ls8im
  %ln8Br = add i64 %ln8Bp, %ln8Bq
  store i64 %ln8Br, i64* %ls8iG
  %ln8Bs = load i64, i64* %ls8iG
  %ln8Bt = load i64, i64* %ls8iF
  %ln8Bu = icmp sge i64 %ln8Bs, %ln8Bt
  %ln8Bv = zext i1 %ln8Bu to i64
  switch i64 %ln8Bv, label %c8qV [i64 1, label %c8rP]
c8qV:
  %ln8Bw = load i64, i64* %ls8iG
  %ln8Bx = icmp sgt i64 99999999, %ln8Bw
  %ln8By = zext i1 %ln8Bx to i64
  switch i64 %ln8By, label %c8qx [i64 1, label %c8qT]
c8qx:
  %ln8Bz = load i64, i64* %ls8iF
  %ln8BA = ashr i64 %ln8Bz, 3
  store i64 %ln8BA, i64* %ls8iK
  %ln8BB = load i64, i64* %ls8iq
  %ln8BC = add i64 %ln8BB, 16
  %ln8BD = load i64, i64* %ls8io
  %ln8BE = load i64, i64* %ls8iK
  %ln8BF = add i64 %ln8BD, %ln8BE
  %ln8BG = add i64 %ln8BC, %ln8BF
  %ln8BH = inttoptr i64 %ln8BG to i8*
  %ln8BI = load i8, i8* %ln8BH, !tbaa !1
  %ln8BJ = zext i8 %ln8BI to i64
  store i64 %ln8BJ, i64* %ls8iO
  %ln8BL = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @s8iS_info$def to i64
  %ln8BK = load i64*, i64** %Hp_Var
  %ln8BM = getelementptr inbounds i64, i64* %ln8BK, i32 -4
  store i64 %ln8BL, i64* %ln8BM, !tbaa !3
  %ln8BO = load i64, i64* %ls8iq
  %ln8BN = load i64*, i64** %Hp_Var
  %ln8BP = getelementptr inbounds i64, i64* %ln8BN, i32 -3
  store i64 %ln8BO, i64* %ln8BP, !tbaa !3
  %ln8BR = load i64, i64* %ls8io
  %ln8BQ = load i64*, i64** %Hp_Var
  %ln8BS = getelementptr inbounds i64, i64* %ln8BQ, i32 -2
  store i64 %ln8BR, i64* %ln8BS, !tbaa !3
  %ln8BT = load i64, i64* %ls8iG
  %ln8BU = load i64, i64* %ls8iF
  %ln8BV = sub i64 %ln8BT, %ln8BU
  store i64 %ln8BV, i64* %ls8iQ
  %ln8BX = load i64, i64* %ls8iQ
  %ln8BW = load i64*, i64** %Hp_Var
  %ln8BY = getelementptr inbounds i64, i64* %ln8BW, i32 -1
  store i64 %ln8BX, i64* %ln8BY, !tbaa !3
  %ln8C0 = load i64, i64* %ls8iQ
  %ln8C1 = sub i64 99999999, %ln8C0
  %ln8BZ = load i64*, i64** %Hp_Var
  %ln8C2 = getelementptr inbounds i64, i64* %ln8BZ, i32 0
  store i64 %ln8C1, i64* %ln8C2, !tbaa !3
  %ln8C3 = load i64, i64* %ls8iF
  %ln8C4 = and i64 %ln8C3, 7
  store i64 %ln8C4, i64* %ls8iP
  %ln8C6 = load i64*, i64** %Hp_Var
  %ln8C7 = ptrtoint i64* %ln8C6 to i64
  %ln8C8 = add i64 %ln8C7, -30
  store i64 %ln8C8, i64* %lc8mM
  %ln8C9 = load i64, i64* %ls8iP
  %ln8Ca = icmp sge i64 %ln8C9, 64
  %ln8Cb = zext i1 %ln8Ca to i64
  switch i64 %ln8Cb, label %c8ql [i64 1, label %c8qt]
c8ql:
  %ln8Cc = load i64, i64* %ls8iq
  %ln8Cd = add i64 %ln8Cc, 16
  %ln8Ce = load i64, i64* %ls8io
  %ln8Cf = load i64, i64* %ls8iK
  %ln8Cg = add i64 %ln8Ce, %ln8Cf
  %ln8Ch = add i64 %ln8Cd, %ln8Cg
  %ln8Ci = load i64, i64* %ls8iO
  %ln8Cj = load i64, i64* %ls8iP
  %ln8Ck = shl i64 1, %ln8Cj
  %ln8Cl = trunc i64 %ln8Ck to i8
  %ln8Cm = zext i8 %ln8Cl to i64
  %ln8Cn = or i64 %ln8Ci, %ln8Cm
  %ln8Co = trunc i64 %ln8Cn to i8
  %ln8Cp = inttoptr i64 %ln8Ch to i8*
  store i8 %ln8Co, i8* %ln8Cp, !tbaa !1
  %ln8Cr = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @c8qj_info$def to i64
  %ln8Cq = load i64*, i64** %Sp_Var
  %ln8Cs = getelementptr inbounds i64, i64* %ln8Cq, i32 0
  store i64 %ln8Cr, i64* %ln8Cs, !tbaa !2
  %ln8Ct = load i64, i64* %ls8iG
  store i64 %ln8Ct, i64* %R2_Var
  %ln8Cu = load i64, i64* %lc8mM
  store i64 %ln8Cu, i64* %R1_Var
  %ln8Cv = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @s8iS_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8Cw = load i64*, i64** %Sp_Var
  %ln8Cx = load i64*, i64** %Hp_Var
  %ln8Cy = load i64, i64* %R1_Var
  %ln8Cz = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8Cv( i64* %Base_Arg, i64* %ln8Cw, i64* %ln8Cx, i64 %ln8Cy, i64 %ln8Cz, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
c8qt:
  %ln8CA = load i64, i64* %ls8iq
  %ln8CB = add i64 %ln8CA, 16
  %ln8CC = load i64, i64* %ls8io
  %ln8CD = load i64, i64* %ls8iK
  %ln8CE = add i64 %ln8CC, %ln8CD
  %ln8CF = add i64 %ln8CB, %ln8CE
  %ln8CG = load i64, i64* %ls8iO
  %ln8CH = trunc i64 %ln8CG to i8
  %ln8CI = inttoptr i64 %ln8CF to i8*
  store i8 %ln8CH, i8* %ln8CI, !tbaa !1
  %ln8CK = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @c8qs_info$def to i64
  %ln8CJ = load i64*, i64** %Sp_Var
  %ln8CL = getelementptr inbounds i64, i64* %ln8CJ, i32 0
  store i64 %ln8CK, i64* %ln8CL, !tbaa !2
  %ln8CM = load i64, i64* %ls8iG
  store i64 %ln8CM, i64* %R2_Var
  %ln8CN = load i64, i64* %lc8mM
  store i64 %ln8CN, i64* %R1_Var
  %ln8CO = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @s8iS_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8CP = load i64*, i64** %Sp_Var
  %ln8CQ = load i64*, i64** %Hp_Var
  %ln8CR = load i64, i64* %R1_Var
  %ln8CS = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8CO( i64* %Base_Arg, i64* %ln8CP, i64* %ln8CQ, i64 %ln8CR, i64 %ln8CS, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
c8qT:
  %ln8CT = load i64, i64* %ls8iF
  %ln8CU = icmp sgt i64 99999999, %ln8CT
  %ln8CV = zext i1 %ln8CU to i64
  switch i64 %ln8CV, label %c8qR [i64 1, label %c8qS]
c8qR:
  %ln8CW = load i64, i64* %ls8iF
  %ln8CX = ashr i64 %ln8CW, 3
  store i64 %ln8CX, i64* %ls8jM
  %ln8CY = load i64, i64* %ls8iq
  %ln8CZ = add i64 %ln8CY, 16
  %ln8D0 = load i64, i64* %ls8io
  %ln8D1 = load i64, i64* %ls8jM
  %ln8D2 = add i64 %ln8D0, %ln8D1
  %ln8D3 = add i64 %ln8CZ, %ln8D2
  %ln8D4 = inttoptr i64 %ln8D3 to i8*
  %ln8D5 = load i8, i8* %ln8D4, !tbaa !1
  %ln8D6 = zext i8 %ln8D5 to i64
  store i64 %ln8D6, i64* %ls8jQ
  %ln8D7 = load i64, i64* %ls8iF
  %ln8D8 = and i64 %ln8D7, 7
  store i64 %ln8D8, i64* %ls8jR
  %ln8D9 = load i64, i64* %ls8jR
  %ln8Da = icmp sge i64 %ln8D9, 64
  %ln8Db = zext i1 %ln8Da to i64
  switch i64 %ln8Db, label %c8qO [i64 1, label %c8qP]
c8qO:
  %ln8Dc = load i64, i64* %ls8iq
  %ln8Dd = add i64 %ln8Dc, 16
  %ln8De = load i64, i64* %ls8io
  %ln8Df = load i64, i64* %ls8jM
  %ln8Dg = add i64 %ln8De, %ln8Df
  %ln8Dh = add i64 %ln8Dd, %ln8Dg
  %ln8Di = load i64, i64* %ls8jQ
  %ln8Dj = load i64, i64* %ls8jR
  %ln8Dk = shl i64 1, %ln8Dj
  %ln8Dl = trunc i64 %ln8Dk to i8
  %ln8Dm = zext i8 %ln8Dl to i64
  %ln8Dn = or i64 %ln8Di, %ln8Dm
  %ln8Do = trunc i64 %ln8Dn to i8
  %ln8Dp = inttoptr i64 %ln8Dh to i8*
  store i8 %ln8Do, i8* %ln8Dp, !tbaa !1
  %ln8Dq = load i64*, i64** %Hp_Var
  %ln8Dr = getelementptr inbounds i64, i64* %ln8Dq, i32 -5
  %ln8Ds = ptrtoint i64* %ln8Dr to i64
  %ln8Dt = inttoptr i64 %ln8Ds to i64*
  store i64* %ln8Dt, i64** %Hp_Var
  %ln8Dv = load i64, i64* %ls8im
  %ln8Dw = add i64 %ln8Dv, 1
  %ln8Du = load i64*, i64** %Sp_Var
  %ln8Dx = getelementptr inbounds i64, i64* %ln8Du, i32 1
  store i64 %ln8Dw, i64* %ln8Dx, !tbaa !2
  %ln8Dz = load i64, i64* %ls8in
  %ln8DA = add i64 %ln8Dz, 1
  %ln8Dy = load i64*, i64** %Sp_Var
  %ln8DB = getelementptr inbounds i64, i64* %ln8Dy, i32 2
  store i64 %ln8DA, i64* %ln8DB, !tbaa !2
  %ln8DD = load i64, i64* %ls8io
  %ln8DC = load i64*, i64** %Sp_Var
  %ln8DE = getelementptr inbounds i64, i64* %ln8DC, i32 3
  store i64 %ln8DD, i64* %ln8DE, !tbaa !2
  %ln8DG = load i64, i64* %ls8ip
  %ln8DF = load i64*, i64** %Sp_Var
  %ln8DH = getelementptr inbounds i64, i64* %ln8DF, i32 4
  store i64 %ln8DG, i64* %ln8DH, !tbaa !2
  %ln8DJ = load i64, i64* %ls8iq
  %ln8DI = load i64*, i64** %Sp_Var
  %ln8DK = getelementptr inbounds i64, i64* %ln8DI, i32 5
  store i64 %ln8DJ, i64* %ln8DK, !tbaa !2
  %ln8DL = load i64*, i64** %Sp_Var
  %ln8DM = getelementptr inbounds i64, i64* %ln8DL, i32 1
  %ln8DN = ptrtoint i64* %ln8DM to i64
  %ln8DO = inttoptr i64 %ln8DN to i64*
  store i64* %ln8DO, i64** %Sp_Var
  br label %u8tG
u8tG:
  %ln8DP = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_c8lK$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8DQ = load i64*, i64** %Sp_Var
  %ln8DR = load i64*, i64** %Hp_Var
  %ln8DS = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8DP( i64* %Base_Arg, i64* %ln8DQ, i64* %ln8DR, i64 %ln8DS, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
c8qP:
  %ln8DT = load i64, i64* %ls8iq
  %ln8DU = add i64 %ln8DT, 16
  %ln8DV = load i64, i64* %ls8io
  %ln8DW = load i64, i64* %ls8jM
  %ln8DX = add i64 %ln8DV, %ln8DW
  %ln8DY = add i64 %ln8DU, %ln8DX
  %ln8DZ = load i64, i64* %ls8jQ
  %ln8E0 = trunc i64 %ln8DZ to i8
  %ln8E1 = inttoptr i64 %ln8DY to i8*
  store i8 %ln8E0, i8* %ln8E1, !tbaa !1
  %ln8E2 = load i64*, i64** %Hp_Var
  %ln8E3 = getelementptr inbounds i64, i64* %ln8E2, i32 -5
  %ln8E4 = ptrtoint i64* %ln8E3 to i64
  %ln8E5 = inttoptr i64 %ln8E4 to i64*
  store i64* %ln8E5, i64** %Hp_Var
  %ln8E7 = load i64, i64* %ls8im
  %ln8E8 = add i64 %ln8E7, 1
  %ln8E6 = load i64*, i64** %Sp_Var
  %ln8E9 = getelementptr inbounds i64, i64* %ln8E6, i32 1
  store i64 %ln8E8, i64* %ln8E9, !tbaa !2
  %ln8Eb = load i64, i64* %ls8in
  %ln8Ec = add i64 %ln8Eb, 1
  %ln8Ea = load i64*, i64** %Sp_Var
  %ln8Ed = getelementptr inbounds i64, i64* %ln8Ea, i32 2
  store i64 %ln8Ec, i64* %ln8Ed, !tbaa !2
  %ln8Ef = load i64, i64* %ls8io
  %ln8Ee = load i64*, i64** %Sp_Var
  %ln8Eg = getelementptr inbounds i64, i64* %ln8Ee, i32 3
  store i64 %ln8Ef, i64* %ln8Eg, !tbaa !2
  %ln8Ei = load i64, i64* %ls8ip
  %ln8Eh = load i64*, i64** %Sp_Var
  %ln8Ej = getelementptr inbounds i64, i64* %ln8Eh, i32 4
  store i64 %ln8Ei, i64* %ln8Ej, !tbaa !2
  %ln8El = load i64, i64* %ls8iq
  %ln8Ek = load i64*, i64** %Sp_Var
  %ln8Em = getelementptr inbounds i64, i64* %ln8Ek, i32 5
  store i64 %ln8El, i64* %ln8Em, !tbaa !2
  %ln8En = load i64*, i64** %Sp_Var
  %ln8Eo = getelementptr inbounds i64, i64* %ln8En, i32 1
  %ln8Ep = ptrtoint i64* %ln8Eo to i64
  %ln8Eq = inttoptr i64 %ln8Ep to i64*
  store i64* %ln8Eq, i64** %Sp_Var
  br label %u8tG
c8qS:
  %ln8Er = load i64*, i64** %Hp_Var
  %ln8Es = getelementptr inbounds i64, i64* %ln8Er, i32 -5
  %ln8Et = ptrtoint i64* %ln8Es to i64
  %ln8Eu = inttoptr i64 %ln8Et to i64*
  store i64* %ln8Eu, i64** %Hp_Var
  %ln8Ew = load i64, i64* %ls8im
  %ln8Ex = add i64 %ln8Ew, 1
  %ln8Ev = load i64*, i64** %Sp_Var
  %ln8Ey = getelementptr inbounds i64, i64* %ln8Ev, i32 1
  store i64 %ln8Ex, i64* %ln8Ey, !tbaa !2
  %ln8EA = load i64, i64* %ls8in
  %ln8EB = add i64 %ln8EA, 1
  %ln8Ez = load i64*, i64** %Sp_Var
  %ln8EC = getelementptr inbounds i64, i64* %ln8Ez, i32 2
  store i64 %ln8EB, i64* %ln8EC, !tbaa !2
  %ln8EE = load i64, i64* %ls8io
  %ln8ED = load i64*, i64** %Sp_Var
  %ln8EF = getelementptr inbounds i64, i64* %ln8ED, i32 3
  store i64 %ln8EE, i64* %ln8EF, !tbaa !2
  %ln8EH = load i64, i64* %ls8ip
  %ln8EG = load i64*, i64** %Sp_Var
  %ln8EI = getelementptr inbounds i64, i64* %ln8EG, i32 4
  store i64 %ln8EH, i64* %ln8EI, !tbaa !2
  %ln8EK = load i64, i64* %ls8iq
  %ln8EJ = load i64*, i64** %Sp_Var
  %ln8EL = getelementptr inbounds i64, i64* %ln8EJ, i32 5
  store i64 %ln8EK, i64* %ln8EL, !tbaa !2
  %ln8EM = load i64*, i64** %Sp_Var
  %ln8EN = getelementptr inbounds i64, i64* %ln8EM, i32 1
  %ln8EO = ptrtoint i64* %ln8EN to i64
  %ln8EP = inttoptr i64 %ln8EO to i64*
  store i64* %ln8EP, i64** %Sp_Var
  br label %u8tG
c8rP:
  %ln8EQ = load i64, i64* %ls8iG
  %ln8ER = icmp slt i64 99999999, %ln8EQ
  %ln8ES = zext i1 %ln8ER to i64
  switch i64 %ln8ES, label %c8rs [i64 1, label %c8rO]
c8rs:
  %ln8ET = load i64, i64* %ls8iF
  %ln8EU = ashr i64 %ln8ET, 3
  store i64 %ln8EU, i64* %ls8k8
  %ln8EV = load i64, i64* %ls8iq
  %ln8EW = add i64 %ln8EV, 16
  %ln8EX = load i64, i64* %ls8io
  %ln8EY = load i64, i64* %ls8k8
  %ln8EZ = add i64 %ln8EX, %ln8EY
  %ln8F0 = add i64 %ln8EW, %ln8EZ
  %ln8F1 = inttoptr i64 %ln8F0 to i8*
  %ln8F2 = load i8, i8* %ln8F1, !tbaa !1
  %ln8F3 = zext i8 %ln8F2 to i64
  store i64 %ln8F3, i64* %ls8kc
  %ln8F5 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @s8kg_info$def to i64
  %ln8F4 = load i64*, i64** %Hp_Var
  %ln8F6 = getelementptr inbounds i64, i64* %ln8F4, i32 -4
  store i64 %ln8F5, i64* %ln8F6, !tbaa !3
  %ln8F8 = load i64, i64* %ls8iq
  %ln8F7 = load i64*, i64** %Hp_Var
  %ln8F9 = getelementptr inbounds i64, i64* %ln8F7, i32 -3
  store i64 %ln8F8, i64* %ln8F9, !tbaa !3
  %ln8Fb = load i64, i64* %ls8io
  %ln8Fa = load i64*, i64** %Hp_Var
  %ln8Fc = getelementptr inbounds i64, i64* %ln8Fa, i32 -2
  store i64 %ln8Fb, i64* %ln8Fc, !tbaa !3
  %ln8Fd = load i64, i64* %ls8iG
  %ln8Fe = load i64, i64* %ls8iF
  %ln8Ff = sub i64 %ln8Fd, %ln8Fe
  store i64 %ln8Ff, i64* %ls8ke
  %ln8Fh = load i64, i64* %ls8ke
  %ln8Fg = load i64*, i64** %Hp_Var
  %ln8Fi = getelementptr inbounds i64, i64* %ln8Fg, i32 -1
  store i64 %ln8Fh, i64* %ln8Fi, !tbaa !3
  %ln8Fk = load i64, i64* %ls8ke
  %ln8Fl = sub i64 99999999, %ln8Fk
  %ln8Fj = load i64*, i64** %Hp_Var
  %ln8Fm = getelementptr inbounds i64, i64* %ln8Fj, i32 0
  store i64 %ln8Fl, i64* %ln8Fm, !tbaa !3
  %ln8Fn = load i64, i64* %ls8iF
  %ln8Fo = and i64 %ln8Fn, 7
  store i64 %ln8Fo, i64* %ls8kd
  %ln8Fq = load i64*, i64** %Hp_Var
  %ln8Fr = ptrtoint i64* %ln8Fq to i64
  %ln8Fs = add i64 %ln8Fr, -30
  store i64 %ln8Fs, i64* %lc8oo
  %ln8Ft = load i64, i64* %ls8kd
  %ln8Fu = icmp sge i64 %ln8Ft, 64
  %ln8Fv = zext i1 %ln8Fu to i64
  switch i64 %ln8Fv, label %c8rg [i64 1, label %c8ro]
c8rg:
  %ln8Fw = load i64, i64* %ls8iq
  %ln8Fx = add i64 %ln8Fw, 16
  %ln8Fy = load i64, i64* %ls8io
  %ln8Fz = load i64, i64* %ls8k8
  %ln8FA = add i64 %ln8Fy, %ln8Fz
  %ln8FB = add i64 %ln8Fx, %ln8FA
  %ln8FC = load i64, i64* %ls8kc
  %ln8FD = load i64, i64* %ls8kd
  %ln8FE = shl i64 1, %ln8FD
  %ln8FF = trunc i64 %ln8FE to i8
  %ln8FG = zext i8 %ln8FF to i64
  %ln8FH = or i64 %ln8FC, %ln8FG
  %ln8FI = trunc i64 %ln8FH to i8
  %ln8FJ = inttoptr i64 %ln8FB to i8*
  store i8 %ln8FI, i8* %ln8FJ, !tbaa !1
  %ln8FL = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @c8re_info$def to i64
  %ln8FK = load i64*, i64** %Sp_Var
  %ln8FM = getelementptr inbounds i64, i64* %ln8FK, i32 0
  store i64 %ln8FL, i64* %ln8FM, !tbaa !2
  %ln8FN = load i64, i64* %ls8iG
  store i64 %ln8FN, i64* %R2_Var
  %ln8FO = load i64, i64* %lc8oo
  store i64 %ln8FO, i64* %R1_Var
  %ln8FP = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @s8kg_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8FQ = load i64*, i64** %Sp_Var
  %ln8FR = load i64*, i64** %Hp_Var
  %ln8FS = load i64, i64* %R1_Var
  %ln8FT = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8FP( i64* %Base_Arg, i64* %ln8FQ, i64* %ln8FR, i64 %ln8FS, i64 %ln8FT, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
c8ro:
  %ln8FU = load i64, i64* %ls8iq
  %ln8FV = add i64 %ln8FU, 16
  %ln8FW = load i64, i64* %ls8io
  %ln8FX = load i64, i64* %ls8k8
  %ln8FY = add i64 %ln8FW, %ln8FX
  %ln8FZ = add i64 %ln8FV, %ln8FY
  %ln8G0 = load i64, i64* %ls8kc
  %ln8G1 = trunc i64 %ln8G0 to i8
  %ln8G2 = inttoptr i64 %ln8FZ to i8*
  store i8 %ln8G1, i8* %ln8G2, !tbaa !1
  %ln8G4 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @c8rn_info$def to i64
  %ln8G3 = load i64*, i64** %Sp_Var
  %ln8G5 = getelementptr inbounds i64, i64* %ln8G3, i32 0
  store i64 %ln8G4, i64* %ln8G5, !tbaa !2
  %ln8G6 = load i64, i64* %ls8iG
  store i64 %ln8G6, i64* %R2_Var
  %ln8G7 = load i64, i64* %lc8oo
  store i64 %ln8G7, i64* %R1_Var
  %ln8G8 = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @s8kg_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8G9 = load i64*, i64** %Sp_Var
  %ln8Ga = load i64*, i64** %Hp_Var
  %ln8Gb = load i64, i64* %R1_Var
  %ln8Gc = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8G8( i64* %Base_Arg, i64* %ln8G9, i64* %ln8Ga, i64 %ln8Gb, i64 %ln8Gc, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
c8rO:
  %ln8Gd = load i64, i64* %ls8iF
  %ln8Ge = icmp slt i64 99999999, %ln8Gd
  %ln8Gf = zext i1 %ln8Ge to i64
  switch i64 %ln8Gf, label %c8rM [i64 1, label %c8rN]
c8rM:
  %ln8Gg = load i64, i64* %ls8iF
  %ln8Gh = ashr i64 %ln8Gg, 3
  store i64 %ln8Gh, i64* %ls8la
  %ln8Gi = load i64, i64* %ls8iq
  %ln8Gj = add i64 %ln8Gi, 16
  %ln8Gk = load i64, i64* %ls8io
  %ln8Gl = load i64, i64* %ls8la
  %ln8Gm = add i64 %ln8Gk, %ln8Gl
  %ln8Gn = add i64 %ln8Gj, %ln8Gm
  %ln8Go = inttoptr i64 %ln8Gn to i8*
  %ln8Gp = load i8, i8* %ln8Go, !tbaa !1
  %ln8Gq = zext i8 %ln8Gp to i64
  store i64 %ln8Gq, i64* %ls8le
  %ln8Gr = load i64, i64* %ls8iF
  %ln8Gs = and i64 %ln8Gr, 7
  store i64 %ln8Gs, i64* %ls8lf
  %ln8Gt = load i64, i64* %ls8lf
  %ln8Gu = icmp sge i64 %ln8Gt, 64
  %ln8Gv = zext i1 %ln8Gu to i64
  switch i64 %ln8Gv, label %c8rJ [i64 1, label %c8rK]
c8rJ:
  %ln8Gw = load i64, i64* %ls8iq
  %ln8Gx = add i64 %ln8Gw, 16
  %ln8Gy = load i64, i64* %ls8io
  %ln8Gz = load i64, i64* %ls8la
  %ln8GA = add i64 %ln8Gy, %ln8Gz
  %ln8GB = add i64 %ln8Gx, %ln8GA
  %ln8GC = load i64, i64* %ls8le
  %ln8GD = load i64, i64* %ls8lf
  %ln8GE = shl i64 1, %ln8GD
  %ln8GF = trunc i64 %ln8GE to i8
  %ln8GG = zext i8 %ln8GF to i64
  %ln8GH = or i64 %ln8GC, %ln8GG
  %ln8GI = trunc i64 %ln8GH to i8
  %ln8GJ = inttoptr i64 %ln8GB to i8*
  store i8 %ln8GI, i8* %ln8GJ, !tbaa !1
  %ln8GK = load i64*, i64** %Hp_Var
  %ln8GL = getelementptr inbounds i64, i64* %ln8GK, i32 -5
  %ln8GM = ptrtoint i64* %ln8GL to i64
  %ln8GN = inttoptr i64 %ln8GM to i64*
  store i64* %ln8GN, i64** %Hp_Var
  %ln8GP = load i64, i64* %ls8im
  %ln8GQ = add i64 %ln8GP, 1
  %ln8GO = load i64*, i64** %Sp_Var
  %ln8GR = getelementptr inbounds i64, i64* %ln8GO, i32 1
  store i64 %ln8GQ, i64* %ln8GR, !tbaa !2
  %ln8GT = load i64, i64* %ls8in
  %ln8GU = add i64 %ln8GT, 1
  %ln8GS = load i64*, i64** %Sp_Var
  %ln8GV = getelementptr inbounds i64, i64* %ln8GS, i32 2
  store i64 %ln8GU, i64* %ln8GV, !tbaa !2
  %ln8GX = load i64, i64* %ls8io
  %ln8GW = load i64*, i64** %Sp_Var
  %ln8GY = getelementptr inbounds i64, i64* %ln8GW, i32 3
  store i64 %ln8GX, i64* %ln8GY, !tbaa !2
  %ln8H0 = load i64, i64* %ls8ip
  %ln8GZ = load i64*, i64** %Sp_Var
  %ln8H1 = getelementptr inbounds i64, i64* %ln8GZ, i32 4
  store i64 %ln8H0, i64* %ln8H1, !tbaa !2
  %ln8H3 = load i64, i64* %ls8iq
  %ln8H2 = load i64*, i64** %Sp_Var
  %ln8H4 = getelementptr inbounds i64, i64* %ln8H2, i32 5
  store i64 %ln8H3, i64* %ln8H4, !tbaa !2
  %ln8H5 = load i64*, i64** %Sp_Var
  %ln8H6 = getelementptr inbounds i64, i64* %ln8H5, i32 1
  %ln8H7 = ptrtoint i64* %ln8H6 to i64
  %ln8H8 = inttoptr i64 %ln8H7 to i64*
  store i64* %ln8H8, i64** %Sp_Var
  br label %u8tG
c8rK:
  %ln8H9 = load i64, i64* %ls8iq
  %ln8Ha = add i64 %ln8H9, 16
  %ln8Hb = load i64, i64* %ls8io
  %ln8Hc = load i64, i64* %ls8la
  %ln8Hd = add i64 %ln8Hb, %ln8Hc
  %ln8He = add i64 %ln8Ha, %ln8Hd
  %ln8Hf = load i64, i64* %ls8le
  %ln8Hg = trunc i64 %ln8Hf to i8
  %ln8Hh = inttoptr i64 %ln8He to i8*
  store i8 %ln8Hg, i8* %ln8Hh, !tbaa !1
  %ln8Hi = load i64*, i64** %Hp_Var
  %ln8Hj = getelementptr inbounds i64, i64* %ln8Hi, i32 -5
  %ln8Hk = ptrtoint i64* %ln8Hj to i64
  %ln8Hl = inttoptr i64 %ln8Hk to i64*
  store i64* %ln8Hl, i64** %Hp_Var
  %ln8Hn = load i64, i64* %ls8im
  %ln8Ho = add i64 %ln8Hn, 1
  %ln8Hm = load i64*, i64** %Sp_Var
  %ln8Hp = getelementptr inbounds i64, i64* %ln8Hm, i32 1
  store i64 %ln8Ho, i64* %ln8Hp, !tbaa !2
  %ln8Hr = load i64, i64* %ls8in
  %ln8Hs = add i64 %ln8Hr, 1
  %ln8Hq = load i64*, i64** %Sp_Var
  %ln8Ht = getelementptr inbounds i64, i64* %ln8Hq, i32 2
  store i64 %ln8Hs, i64* %ln8Ht, !tbaa !2
  %ln8Hv = load i64, i64* %ls8io
  %ln8Hu = load i64*, i64** %Sp_Var
  %ln8Hw = getelementptr inbounds i64, i64* %ln8Hu, i32 3
  store i64 %ln8Hv, i64* %ln8Hw, !tbaa !2
  %ln8Hy = load i64, i64* %ls8ip
  %ln8Hx = load i64*, i64** %Sp_Var
  %ln8Hz = getelementptr inbounds i64, i64* %ln8Hx, i32 4
  store i64 %ln8Hy, i64* %ln8Hz, !tbaa !2
  %ln8HB = load i64, i64* %ls8iq
  %ln8HA = load i64*, i64** %Sp_Var
  %ln8HC = getelementptr inbounds i64, i64* %ln8HA, i32 5
  store i64 %ln8HB, i64* %ln8HC, !tbaa !2
  %ln8HD = load i64*, i64** %Sp_Var
  %ln8HE = getelementptr inbounds i64, i64* %ln8HD, i32 1
  %ln8HF = ptrtoint i64* %ln8HE to i64
  %ln8HG = inttoptr i64 %ln8HF to i64*
  store i64* %ln8HG, i64** %Sp_Var
  br label %u8tG
c8rN:
  %ln8HH = load i64*, i64** %Hp_Var
  %ln8HI = getelementptr inbounds i64, i64* %ln8HH, i32 -5
  %ln8HJ = ptrtoint i64* %ln8HI to i64
  %ln8HK = inttoptr i64 %ln8HJ to i64*
  store i64* %ln8HK, i64** %Hp_Var
  %ln8HM = load i64, i64* %ls8im
  %ln8HN = add i64 %ln8HM, 1
  %ln8HL = load i64*, i64** %Sp_Var
  %ln8HO = getelementptr inbounds i64, i64* %ln8HL, i32 1
  store i64 %ln8HN, i64* %ln8HO, !tbaa !2
  %ln8HQ = load i64, i64* %ls8in
  %ln8HR = add i64 %ln8HQ, 1
  %ln8HP = load i64*, i64** %Sp_Var
  %ln8HS = getelementptr inbounds i64, i64* %ln8HP, i32 2
  store i64 %ln8HR, i64* %ln8HS, !tbaa !2
  %ln8HU = load i64, i64* %ls8io
  %ln8HT = load i64*, i64** %Sp_Var
  %ln8HV = getelementptr inbounds i64, i64* %ln8HT, i32 3
  store i64 %ln8HU, i64* %ln8HV, !tbaa !2
  %ln8HX = load i64, i64* %ls8ip
  %ln8HW = load i64*, i64** %Sp_Var
  %ln8HY = getelementptr inbounds i64, i64* %ln8HW, i32 4
  store i64 %ln8HX, i64* %ln8HY, !tbaa !2
  %ln8I0 = load i64, i64* %ls8iq
  %ln8HZ = load i64*, i64** %Sp_Var
  %ln8I1 = getelementptr inbounds i64, i64* %ln8HZ, i32 5
  store i64 %ln8I0, i64* %ln8I1, !tbaa !2
  %ln8I2 = load i64*, i64** %Sp_Var
  %ln8I3 = getelementptr inbounds i64, i64* %ln8I2, i32 1
  %ln8I4 = ptrtoint i64* %ln8I3 to i64
  %ln8I5 = inttoptr i64 %ln8I4 to i64*
  store i64* %ln8I5, i64** %Sp_Var
  br label %u8tG
c8q0:
  %ln8I6 = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 40, i64* %ln8I6, !tbaa !5
  %ln8I7 = load i64*, i64** %Sp_Var
  %ln8I8 = getelementptr inbounds i64, i64* %ln8I7, i32 0
  %ln8I9 = bitcast i64* %ln8I8 to i64*
  %ln8Ia = load i64, i64* %ln8I9, !tbaa !2
  store i64 %ln8Ia, i64* %ls8iD
  %ln8Ic = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @c8mf_info$def to i64
  %ln8Ib = load i64*, i64** %Sp_Var
  %ln8Id = getelementptr inbounds i64, i64* %ln8Ib, i32 0
  store i64 %ln8Ic, i64* %ln8Id, !tbaa !2
  %ln8Ie = load i64, i64* %ls8iD
  store i64 %ln8Ie, i64* %R1_Var
  %ln8If = bitcast i8* @stg_gc_unbx_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8Ig = load i64*, i64** %Sp_Var
  %ln8Ih = load i64*, i64** %Hp_Var
  %ln8Ii = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8If( i64* %Base_Arg, i64* %ln8Ig, i64* %ln8Ih, i64 %ln8Ii, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.479605764 UTC

@c8mf_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @c8mf_info$def to i8*)
define internal ghccc void @c8mf_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64}><{i64 965, i64 30}>
{
c8mf:
  %ln8Ij = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %R1_Arg, i64* %ln8Ij, !tbaa !2
  %ln8Ik = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_c8mg$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8Ik( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.482314069 UTC

@c8rn_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @c8rn_info$def to i8*)
define internal ghccc void @c8rn_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64}><{i64 965, i64 30}>
{
c8rn:
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %ln8Im = load i64*, i64** %Sp_Var
  %ln8In = getelementptr inbounds i64, i64* %ln8Im, i32 1
  %ln8Io = bitcast i64* %ln8In to i64*
  %ln8Ip = load i64, i64* %ln8Io, !tbaa !2
  %ln8Iq = add i64 %ln8Ip, 1
  %ln8Il = load i64*, i64** %Sp_Var
  %ln8Ir = getelementptr inbounds i64, i64* %ln8Il, i32 1
  store i64 %ln8Iq, i64* %ln8Ir, !tbaa !2
  %ln8It = load i64*, i64** %Sp_Var
  %ln8Iu = getelementptr inbounds i64, i64* %ln8It, i32 2
  %ln8Iv = bitcast i64* %ln8Iu to i64*
  %ln8Iw = load i64, i64* %ln8Iv, !tbaa !2
  %ln8Ix = add i64 %ln8Iw, 1
  %ln8Is = load i64*, i64** %Sp_Var
  %ln8Iy = getelementptr inbounds i64, i64* %ln8Is, i32 2
  store i64 %ln8Ix, i64* %ln8Iy, !tbaa !2
  %ln8IA = load i64*, i64** %Sp_Var
  %ln8IB = getelementptr inbounds i64, i64* %ln8IA, i32 3
  %ln8IC = bitcast i64* %ln8IB to i64*
  %ln8ID = load i64, i64* %ln8IC, !tbaa !2
  %ln8Iz = load i64*, i64** %Sp_Var
  %ln8IE = getelementptr inbounds i64, i64* %ln8Iz, i32 3
  store i64 %ln8ID, i64* %ln8IE, !tbaa !2
  %ln8IG = load i64*, i64** %Sp_Var
  %ln8IH = getelementptr inbounds i64, i64* %ln8IG, i32 4
  %ln8II = bitcast i64* %ln8IH to i64*
  %ln8IJ = load i64, i64* %ln8II, !tbaa !2
  %ln8IF = load i64*, i64** %Sp_Var
  %ln8IK = getelementptr inbounds i64, i64* %ln8IF, i32 4
  store i64 %ln8IJ, i64* %ln8IK, !tbaa !2
  %ln8IM = load i64*, i64** %Sp_Var
  %ln8IN = getelementptr inbounds i64, i64* %ln8IM, i32 5
  %ln8IO = bitcast i64* %ln8IN to i64*
  %ln8IP = load i64, i64* %ln8IO, !tbaa !2
  %ln8IL = load i64*, i64** %Sp_Var
  %ln8IQ = getelementptr inbounds i64, i64* %ln8IL, i32 5
  store i64 %ln8IP, i64* %ln8IQ, !tbaa !2
  %ln8IR = load i64*, i64** %Sp_Var
  %ln8IS = getelementptr inbounds i64, i64* %ln8IR, i32 1
  %ln8IT = ptrtoint i64* %ln8IS to i64
  %ln8IU = inttoptr i64 %ln8IT to i64*
  store i64* %ln8IU, i64** %Sp_Var
  %ln8IV = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_c8lK$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8IW = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8IV( i64* %Base_Arg, i64* %ln8IW, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.486063073 UTC

@c8re_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @c8re_info$def to i8*)
define internal ghccc void @c8re_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64}><{i64 965, i64 30}>
{
c8re:
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %ln8IY = load i64*, i64** %Sp_Var
  %ln8IZ = getelementptr inbounds i64, i64* %ln8IY, i32 1
  %ln8J0 = bitcast i64* %ln8IZ to i64*
  %ln8J1 = load i64, i64* %ln8J0, !tbaa !2
  %ln8J2 = add i64 %ln8J1, 1
  %ln8IX = load i64*, i64** %Sp_Var
  %ln8J3 = getelementptr inbounds i64, i64* %ln8IX, i32 1
  store i64 %ln8J2, i64* %ln8J3, !tbaa !2
  %ln8J5 = load i64*, i64** %Sp_Var
  %ln8J6 = getelementptr inbounds i64, i64* %ln8J5, i32 2
  %ln8J7 = bitcast i64* %ln8J6 to i64*
  %ln8J8 = load i64, i64* %ln8J7, !tbaa !2
  %ln8J9 = add i64 %ln8J8, 1
  %ln8J4 = load i64*, i64** %Sp_Var
  %ln8Ja = getelementptr inbounds i64, i64* %ln8J4, i32 2
  store i64 %ln8J9, i64* %ln8Ja, !tbaa !2
  %ln8Jc = load i64*, i64** %Sp_Var
  %ln8Jd = getelementptr inbounds i64, i64* %ln8Jc, i32 3
  %ln8Je = bitcast i64* %ln8Jd to i64*
  %ln8Jf = load i64, i64* %ln8Je, !tbaa !2
  %ln8Jb = load i64*, i64** %Sp_Var
  %ln8Jg = getelementptr inbounds i64, i64* %ln8Jb, i32 3
  store i64 %ln8Jf, i64* %ln8Jg, !tbaa !2
  %ln8Ji = load i64*, i64** %Sp_Var
  %ln8Jj = getelementptr inbounds i64, i64* %ln8Ji, i32 4
  %ln8Jk = bitcast i64* %ln8Jj to i64*
  %ln8Jl = load i64, i64* %ln8Jk, !tbaa !2
  %ln8Jh = load i64*, i64** %Sp_Var
  %ln8Jm = getelementptr inbounds i64, i64* %ln8Jh, i32 4
  store i64 %ln8Jl, i64* %ln8Jm, !tbaa !2
  %ln8Jo = load i64*, i64** %Sp_Var
  %ln8Jp = getelementptr inbounds i64, i64* %ln8Jo, i32 5
  %ln8Jq = bitcast i64* %ln8Jp to i64*
  %ln8Jr = load i64, i64* %ln8Jq, !tbaa !2
  %ln8Jn = load i64*, i64** %Sp_Var
  %ln8Js = getelementptr inbounds i64, i64* %ln8Jn, i32 5
  store i64 %ln8Jr, i64* %ln8Js, !tbaa !2
  %ln8Jt = load i64*, i64** %Sp_Var
  %ln8Ju = getelementptr inbounds i64, i64* %ln8Jt, i32 1
  %ln8Jv = ptrtoint i64* %ln8Ju to i64
  %ln8Jw = inttoptr i64 %ln8Jv to i64*
  store i64* %ln8Jw, i64** %Sp_Var
  %ln8Jx = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_c8lK$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8Jy = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8Jx( i64* %Base_Arg, i64* %ln8Jy, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.489209243 UTC

@c8qs_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @c8qs_info$def to i8*)
define internal ghccc void @c8qs_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64}><{i64 965, i64 30}>
{
c8qs:
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %ln8JA = load i64*, i64** %Sp_Var
  %ln8JB = getelementptr inbounds i64, i64* %ln8JA, i32 1
  %ln8JC = bitcast i64* %ln8JB to i64*
  %ln8JD = load i64, i64* %ln8JC, !tbaa !2
  %ln8JE = add i64 %ln8JD, 1
  %ln8Jz = load i64*, i64** %Sp_Var
  %ln8JF = getelementptr inbounds i64, i64* %ln8Jz, i32 1
  store i64 %ln8JE, i64* %ln8JF, !tbaa !2
  %ln8JH = load i64*, i64** %Sp_Var
  %ln8JI = getelementptr inbounds i64, i64* %ln8JH, i32 2
  %ln8JJ = bitcast i64* %ln8JI to i64*
  %ln8JK = load i64, i64* %ln8JJ, !tbaa !2
  %ln8JL = add i64 %ln8JK, 1
  %ln8JG = load i64*, i64** %Sp_Var
  %ln8JM = getelementptr inbounds i64, i64* %ln8JG, i32 2
  store i64 %ln8JL, i64* %ln8JM, !tbaa !2
  %ln8JO = load i64*, i64** %Sp_Var
  %ln8JP = getelementptr inbounds i64, i64* %ln8JO, i32 3
  %ln8JQ = bitcast i64* %ln8JP to i64*
  %ln8JR = load i64, i64* %ln8JQ, !tbaa !2
  %ln8JN = load i64*, i64** %Sp_Var
  %ln8JS = getelementptr inbounds i64, i64* %ln8JN, i32 3
  store i64 %ln8JR, i64* %ln8JS, !tbaa !2
  %ln8JU = load i64*, i64** %Sp_Var
  %ln8JV = getelementptr inbounds i64, i64* %ln8JU, i32 4
  %ln8JW = bitcast i64* %ln8JV to i64*
  %ln8JX = load i64, i64* %ln8JW, !tbaa !2
  %ln8JT = load i64*, i64** %Sp_Var
  %ln8JY = getelementptr inbounds i64, i64* %ln8JT, i32 4
  store i64 %ln8JX, i64* %ln8JY, !tbaa !2
  %ln8K0 = load i64*, i64** %Sp_Var
  %ln8K1 = getelementptr inbounds i64, i64* %ln8K0, i32 5
  %ln8K2 = bitcast i64* %ln8K1 to i64*
  %ln8K3 = load i64, i64* %ln8K2, !tbaa !2
  %ln8JZ = load i64*, i64** %Sp_Var
  %ln8K4 = getelementptr inbounds i64, i64* %ln8JZ, i32 5
  store i64 %ln8K3, i64* %ln8K4, !tbaa !2
  %ln8K5 = load i64*, i64** %Sp_Var
  %ln8K6 = getelementptr inbounds i64, i64* %ln8K5, i32 1
  %ln8K7 = ptrtoint i64* %ln8K6 to i64
  %ln8K8 = inttoptr i64 %ln8K7 to i64*
  store i64* %ln8K8, i64** %Sp_Var
  %ln8K9 = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_c8lK$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8Ka = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8K9( i64* %Base_Arg, i64* %ln8Ka, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.493245871 UTC

@c8qj_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @c8qj_info$def to i8*)
define internal ghccc void @c8qj_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64}><{i64 965, i64 30}>
{
c8qj:
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %ln8Kc = load i64*, i64** %Sp_Var
  %ln8Kd = getelementptr inbounds i64, i64* %ln8Kc, i32 1
  %ln8Ke = bitcast i64* %ln8Kd to i64*
  %ln8Kf = load i64, i64* %ln8Ke, !tbaa !2
  %ln8Kg = add i64 %ln8Kf, 1
  %ln8Kb = load i64*, i64** %Sp_Var
  %ln8Kh = getelementptr inbounds i64, i64* %ln8Kb, i32 1
  store i64 %ln8Kg, i64* %ln8Kh, !tbaa !2
  %ln8Kj = load i64*, i64** %Sp_Var
  %ln8Kk = getelementptr inbounds i64, i64* %ln8Kj, i32 2
  %ln8Kl = bitcast i64* %ln8Kk to i64*
  %ln8Km = load i64, i64* %ln8Kl, !tbaa !2
  %ln8Kn = add i64 %ln8Km, 1
  %ln8Ki = load i64*, i64** %Sp_Var
  %ln8Ko = getelementptr inbounds i64, i64* %ln8Ki, i32 2
  store i64 %ln8Kn, i64* %ln8Ko, !tbaa !2
  %ln8Kq = load i64*, i64** %Sp_Var
  %ln8Kr = getelementptr inbounds i64, i64* %ln8Kq, i32 3
  %ln8Ks = bitcast i64* %ln8Kr to i64*
  %ln8Kt = load i64, i64* %ln8Ks, !tbaa !2
  %ln8Kp = load i64*, i64** %Sp_Var
  %ln8Ku = getelementptr inbounds i64, i64* %ln8Kp, i32 3
  store i64 %ln8Kt, i64* %ln8Ku, !tbaa !2
  %ln8Kw = load i64*, i64** %Sp_Var
  %ln8Kx = getelementptr inbounds i64, i64* %ln8Kw, i32 4
  %ln8Ky = bitcast i64* %ln8Kx to i64*
  %ln8Kz = load i64, i64* %ln8Ky, !tbaa !2
  %ln8Kv = load i64*, i64** %Sp_Var
  %ln8KA = getelementptr inbounds i64, i64* %ln8Kv, i32 4
  store i64 %ln8Kz, i64* %ln8KA, !tbaa !2
  %ln8KC = load i64*, i64** %Sp_Var
  %ln8KD = getelementptr inbounds i64, i64* %ln8KC, i32 5
  %ln8KE = bitcast i64* %ln8KD to i64*
  %ln8KF = load i64, i64* %ln8KE, !tbaa !2
  %ln8KB = load i64*, i64** %Sp_Var
  %ln8KG = getelementptr inbounds i64, i64* %ln8KB, i32 5
  store i64 %ln8KF, i64* %ln8KG, !tbaa !2
  %ln8KH = load i64*, i64** %Sp_Var
  %ln8KI = getelementptr inbounds i64, i64* %ln8KH, i32 1
  %ln8KJ = ptrtoint i64* %ln8KI to i64
  %ln8KK = inttoptr i64 %ln8KJ to i64*
  store i64* %ln8KK, i64** %Sp_Var
  %ln8KL = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_c8lK$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8KM = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8KL( i64* %Base_Arg, i64* %ln8KM, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.501030502 UTC

%Main_main1_closure_struct = type <{i64, i64}>
@Main_main1_closure$def = internal global %Main_main1_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main1_info$def to i64), i64 0}>
@Main_main1_closure = alias i8, bitcast (%Main_main1_closure_struct* @Main_main1_closure$def to i8*)


==================== LLVM Code ====================
2018-10-14 00:18:47.502223678 UTC

@s8lH_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @s8lH_info$def to i8*)
define internal ghccc void @s8lH_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64}><{i64 1, i64 16}>
{
c8L4:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %ln8Lf = add i64 %R1_Arg, 16
  %ln8Lg = inttoptr i64 %ln8Lf to i64*
  %ln8Lh = load i64, i64* %ln8Lg, !tbaa !4
  store i64 %ln8Lh, i64* %R2_Var
  %ln8Li = bitcast i8* @base_GHCziShow_zdfShowIntzuzdcshow_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8Lj = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8Li( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %ln8Lj, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.504491451 UTC

@Main_main1_info = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main1_info$def to i8*)
define ghccc void @Main_main1_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i64, i64}><{i64 add (i64 sub (i64 ptrtoint (i8* @S8Le_srt to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main1_info$def to i64)),i64 0), i64 4294967299, i64 0, i64 30064771086}>
{
c8L7:
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %ln8Lk = load i64*, i64** %Sp_Var
  %ln8Ll = getelementptr inbounds i64, i64* %ln8Lk, i32 -1
  %ln8Lm = ptrtoint i64* %ln8Ll to i64
  %ln8Ln = icmp ult i64 %ln8Lm, %SpLim_Arg
  %ln8Lo = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %ln8Ln, i1 0 )
  br i1 %ln8Lo, label %c8L8, label %c8L9
c8L9:
  %ln8Lq = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @c8KR_info$def to i64
  %ln8Lp = load i64*, i64** %Sp_Var
  %ln8Lr = getelementptr inbounds i64, i64* %ln8Lp, i32 -1
  store i64 %ln8Lq, i64* %ln8Lr, !tbaa !2
  store i64 12500000, i64* %R1_Var
  %ln8Ls = load i64*, i64** %Sp_Var
  %ln8Lt = getelementptr inbounds i64, i64* %ln8Ls, i32 -1
  %ln8Lu = ptrtoint i64* %ln8Lt to i64
  %ln8Lv = inttoptr i64 %ln8Lu to i64*
  store i64* %ln8Lv, i64** %Sp_Var
  %ln8Lw = bitcast i8* @stg_newByteArrayzh to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8Lx = load i64*, i64** %Sp_Var
  %ln8Ly = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8Lw( i64* %Base_Arg, i64* %ln8Lx, i64* %Hp_Arg, i64 %ln8Ly, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
c8L8:
  %ln8Lz = ptrtoint %Main_main1_closure_struct* @Main_main1_closure$def to i64
  store i64 %ln8Lz, i64* %R1_Var
  %ln8LA = getelementptr inbounds i64, i64* %Base_Arg, i32 -1
  %ln8LB = bitcast i64* %ln8LA to i64*
  %ln8LC = load i64, i64* %ln8LB, !tbaa !5
  %ln8LD = inttoptr i64 %ln8LC to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8LE = load i64*, i64** %Sp_Var
  %ln8LF = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8LD( i64* %Base_Arg, i64* %ln8LE, i64* %Hp_Arg, i64 %ln8LF, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.50866708 UTC

@c8KR_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @c8KR_info$def to i8*)
define internal ghccc void @c8KR_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i64}><{i64 add (i64 sub (i64 ptrtoint (i8* @S8Le_srt to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @c8KR_info$def to i64)),i64 0), i64 0, i64 12884901918}>
{
c8KR:
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %F1_Var = alloca float, i32 1
  store float undef, float* %F1_Var
  %D1_Var = alloca double, i32 1
  store double undef, double* %D1_Var
  %F2_Var = alloca float, i32 1
  store float undef, float* %F2_Var
  %D2_Var = alloca double, i32 1
  store double undef, double* %D2_Var
  %F3_Var = alloca float, i32 1
  store float undef, float* %F3_Var
  %D3_Var = alloca double, i32 1
  store double undef, double* %D3_Var
  %F4_Var = alloca float, i32 1
  store float undef, float* %F4_Var
  %D4_Var = alloca double, i32 1
  store double undef, double* %D4_Var
  %F5_Var = alloca float, i32 1
  store float undef, float* %F5_Var
  %D5_Var = alloca double, i32 1
  store double undef, double* %D5_Var
  %F6_Var = alloca float, i32 1
  store float undef, float* %F6_Var
  %D6_Var = alloca double, i32 1
  store double undef, double* %D6_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %ln8LG = add i64 %R1_Arg, 16
  %ln8LH = inttoptr i64 %ln8LG to i8*
  %ln8LI = bitcast i8* @hsprimitive_memset_Word8 to void (i8*, i64, i64, i64)*
  store i64 undef, i64* %R3_Var
  store i64 undef, i64* %R4_Var
  store i64 undef, i64* %R5_Var
  store i64 undef, i64* %R6_Var
  store float undef, float* %F1_Var
  store double undef, double* %D1_Var
  store float undef, float* %F2_Var
  store double undef, double* %D2_Var
  store float undef, float* %F3_Var
  store double undef, double* %D3_Var
  store float undef, float* %F4_Var
  store double undef, double* %D4_Var
  store float undef, float* %F5_Var
  store double undef, double* %D5_Var
  store float undef, float* %F6_Var
  store double undef, double* %D6_Var
  call ccc void (i8*, i64, i64, i64) %ln8LI( i8* %ln8LH, i64 0, i64 12500000, i64 0 ) nounwind
  %ln8LJ = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @c8KY_info$def to i64
  %ln8LK = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %ln8LJ, i64* %ln8LK, !tbaa !2
  store i64 %R1_Arg, i64* %R6_Var
  store i64 12500000, i64* %R5_Var
  store i64 0, i64* %R4_Var
  store i64 0, i64* %R3_Var
  store i64 2, i64* %R2_Var
  %ln8LL = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_mainzuzdszdwsievefn_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8LM = load i64, i64* %R2_Var
  %ln8LN = load i64, i64* %R3_Var
  %ln8LO = load i64, i64* %R4_Var
  %ln8LP = load i64, i64* %R5_Var
  %ln8LQ = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8LL( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %ln8LM, i64 %ln8LN, i64 %ln8LO, i64 %ln8LP, i64 %ln8LQ, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.513240173 UTC

@c8KY_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @c8KY_info$def to i8*)
define internal ghccc void @c8KY_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i64}><{i64 add (i64 sub (i64 ptrtoint (i8* @S8Le_srt to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @c8KY_info$def to i64)),i64 0), i64 0, i64 12884901918}>
{
c8KY:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %ln8LR = load i64*, i64** %Hp_Var
  %ln8LS = getelementptr inbounds i64, i64* %ln8LR, i32 3
  %ln8LT = ptrtoint i64* %ln8LS to i64
  %ln8LU = inttoptr i64 %ln8LT to i64*
  store i64* %ln8LU, i64** %Hp_Var
  %ln8LV = load i64*, i64** %Hp_Var
  %ln8LW = ptrtoint i64* %ln8LV to i64
  %ln8LX = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %ln8LY = bitcast i64* %ln8LX to i64*
  %ln8LZ = load i64, i64* %ln8LY, !tbaa !5
  %ln8M0 = icmp ugt i64 %ln8LW, %ln8LZ
  %ln8M1 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %ln8M0, i1 0 )
  br i1 %ln8M1, label %c8Ld, label %c8Lc
c8Lc:
  %ln8M3 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @s8lH_info$def to i64
  %ln8M2 = load i64*, i64** %Hp_Var
  %ln8M4 = getelementptr inbounds i64, i64* %ln8M2, i32 -2
  store i64 %ln8M3, i64* %ln8M4, !tbaa !3
  %ln8M6 = load i64, i64* %R1_Var
  %ln8M5 = load i64*, i64** %Hp_Var
  %ln8M7 = getelementptr inbounds i64, i64* %ln8M5, i32 0
  store i64 %ln8M6, i64* %ln8M7, !tbaa !3
  %ln8M8 = ptrtoint i8* @ghczmprim_GHCziTypes_True_closure to i64
  %ln8M9 = add i64 %ln8M8, 2
  store i64 %ln8M9, i64* %R4_Var
  %ln8Ma = load i64*, i64** %Hp_Var
  %ln8Mb = getelementptr inbounds i64, i64* %ln8Ma, i32 -2
  %ln8Mc = ptrtoint i64* %ln8Mb to i64
  store i64 %ln8Mc, i64* %R3_Var
  %ln8Md = ptrtoint i8* @base_GHCziIOziHandleziFD_stdout_closure to i64
  store i64 %ln8Md, i64* %R2_Var
  %ln8Me = load i64*, i64** %Sp_Var
  %ln8Mf = getelementptr inbounds i64, i64* %ln8Me, i32 1
  %ln8Mg = ptrtoint i64* %ln8Mf to i64
  %ln8Mh = inttoptr i64 %ln8Mg to i64*
  store i64* %ln8Mh, i64** %Sp_Var
  %ln8Mi = bitcast i8* @base_GHCziIOziHandleziText_hPutStr2_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8Mj = load i64*, i64** %Sp_Var
  %ln8Mk = load i64*, i64** %Hp_Var
  %ln8Ml = load i64, i64* %R1_Var
  %ln8Mm = load i64, i64* %R2_Var
  %ln8Mn = load i64, i64* %R3_Var
  %ln8Mo = load i64, i64* %R4_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8Mi( i64* %Base_Arg, i64* %ln8Mj, i64* %ln8Mk, i64 %ln8Ml, i64 %ln8Mm, i64 %ln8Mn, i64 %ln8Mo, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
c8Ld:
  %ln8Mp = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 24, i64* %ln8Mp, !tbaa !5
  %ln8Mq = load i64, i64* %R1_Var
  store i64 %ln8Mq, i64* %R1_Var
  %ln8Mr = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8Ms = load i64*, i64** %Sp_Var
  %ln8Mt = load i64*, i64** %Hp_Var
  %ln8Mu = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8Mr( i64* %Base_Arg, i64* %ln8Ms, i64* %ln8Mt, i64 %ln8Mu, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.51809281 UTC

%Main_main_closure_struct = type <{i64, i64}>
@Main_main_closure$def = internal global %Main_main_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main_info$def to i64), i64 0}>
@Main_main_closure = alias i8, bitcast (%Main_main_closure_struct* @Main_main_closure$def to i8*)


==================== LLVM Code ====================
2018-10-14 00:18:47.519209849 UTC

@Main_main_info = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main_info$def to i8*)
define ghccc void @Main_main_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i64, i64}><{i64 add (i64 sub (i64 ptrtoint (i8* @S8Le_srt to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main_info$def to i64)),i64 16), i64 4294967299, i64 0, i64 4294967310}>
{
c8Mz:
  %ln8MC = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main1_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8MC( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.522263673 UTC

%Main_main2_closure_struct = type <{i64, i64}>
@Main_main2_closure$def = internal global %Main_main2_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main2_info$def to i64), i64 0}>
@Main_main2_closure = alias i8, bitcast (%Main_main2_closure_struct* @Main_main2_closure$def to i8*)


==================== LLVM Code ====================
2018-10-14 00:18:47.523459762 UTC

@Main_main2_info = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main2_info$def to i8*)
define ghccc void @Main_main2_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i64, i64}><{i64 add (i64 sub (i64 ptrtoint (i8* @S8Le_srt to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main2_info$def to i64)),i64 16), i64 4294967299, i64 0, i64 12884901902}>
{
c8MH:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %ln8MK = ptrtoint %Main_main1_closure_struct* @Main_main1_closure$def to i64
  %ln8ML = add i64 %ln8MK, 1
  store i64 %ln8ML, i64* %R2_Var
  %ln8MM = bitcast i8* @base_GHCziTopHandler_runMainIO1_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %ln8MN = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8MM( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %ln8MN, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.52599354 UTC

%ZCMain_main_closure_struct = type <{i64, i64}>
@ZCMain_main_closure$def = internal global %ZCMain_main_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ZCMain_main_info$def to i64), i64 0}>
@ZCMain_main_closure = alias i8, bitcast (%ZCMain_main_closure_struct* @ZCMain_main_closure$def to i8*)


==================== LLVM Code ====================
2018-10-14 00:18:47.527664417 UTC

@ZCMain_main_info = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ZCMain_main_info$def to i8*)
define ghccc void @ZCMain_main_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i64, i64}><{i64 add (i64 sub (i64 ptrtoint (i8* @S8Le_srt to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ZCMain_main_info$def to i64)),i64 32), i64 4294967299, i64 0, i64 4294967310}>
{
c8MS:
  %ln8MV = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main2_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %ln8MV( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}


==================== LLVM Code ====================
2018-10-14 00:18:47.529359108 UTC

%S8Le_srt_struct = type <{i64, i64, i64, i64, i64}>
@S8Le_srt$def = internal constant %S8Le_srt_struct<{i64 ptrtoint (i8* @base_GHCziIOziHandleziFD_stdout_closure to i64), i64 ptrtoint (i8* @base_GHCziIOziHandleziText_hPutStr2_closure to i64), i64 ptrtoint (%Main_main1_closure_struct* @Main_main1_closure$def to i64), i64 ptrtoint (i8* @base_GHCziTopHandler_runMainIO1_closure to i64), i64 ptrtoint (%Main_main2_closure_struct* @Main_main2_closure$def to i64)}>
@S8Le_srt = internal alias i8, bitcast (%S8Le_srt_struct* @S8Le_srt$def to i8*)


==================== LLVM Code ====================
2018-10-14 00:18:47.530060537 UTC

@hsprimitive_memset_Word8 = external global i8
@ghczmprim_GHCziTypes_TrNameS_con_info = external global i8
@ghczmprim_GHCziTypes_Module_con_info = external global i8
@stg_gc_unbx_r1 = external global i8
@ghczmprim_GHCziTuple_Z0T_closure = external global i8
@ghczmprim_GHCziTypes_Izh_con_info = external global i8
@stg_gc_unpt_r1 = external global i8
@base_GHCziShow_zdfShowIntzuzdcshow_info = external global i8
@stg_newByteArrayzh = external global i8
@ghczmprim_GHCziTypes_True_closure = external global i8
@base_GHCziIOziHandleziFD_stdout_closure = external global i8
@base_GHCziIOziHandleziText_hPutStr2_info = external global i8
@base_GHCziTopHandler_runMainIO1_info = external global i8
@base_GHCziIOziHandleziText_hPutStr2_closure = external global i8
@base_GHCziTopHandler_runMainIO1_closure = external global i8


==================== LLVM Code ====================
2018-10-14 00:18:47.530714102 UTC

@llvm.used = appending constant [11 x i8*] [i8* bitcast (%S8Le_srt_struct* @S8Le_srt$def to i8*), i8* bitcast (%ZCMain_main_closure_struct* @ZCMain_main_closure$def to i8*), i8* bitcast (%Main_main2_closure_struct* @Main_main2_closure$def to i8*), i8* bitcast (%Main_main_closure_struct* @Main_main_closure$def to i8*), i8* bitcast (%Main_main1_closure_struct* @Main_main1_closure$def to i8*), i8* bitcast (%Main_mainzuzdszdwsievefn_closure_struct* @Main_mainzuzdszdwsievefn_closure$def to i8*), i8* bitcast (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i8*), i8* bitcast (%Main_zdtrModule1_closure_struct* @Main_zdtrModule1_closure$def to i8*), i8* bitcast (%Main_zdtrModule2_bytes_struct* @Main_zdtrModule2_bytes$def to i8*), i8* bitcast (%Main_zdtrModule3_closure_struct* @Main_zdtrModule3_closure$def to i8*), i8* bitcast (%Main_zdtrModule4_bytes_struct* @Main_zdtrModule4_bytes$def to i8*)], section "llvm.metadata"

