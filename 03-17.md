# 17/03

## Carry over from yesterday
- Commit into LLVM made [commit `58a4c1`](https://reviews.llvm.org/D31036)
- Need to check if may-writes are handled correctly after change landed

## Work today

### May writes still handled incorrectly after patch for incorrect creation of dependence information

##### failing `testbed.ll`

```cpp
; RUN: opt %loadPolly -analyze < %s | FileCheck %s
;
; FIXME: Edit the run line and add checks!
;
; XFAIL: *
;
;    static const int N = 3000;
;
;    void f(int A[N], int B[N]) {
;      for (int i = 0; i < N; i++) {
;        //__sync_synchronize();
;        A[i] = 20;
;
;        if (i * i) {
;          //__sync_synchronize();
;          A[i] = 90;
;        }
;
;        //__sync_synchronize();
;        B[i] = A[i];
;      }
;      A[i] = 42;
;    }
;
source_filename = "testbed.c"
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"

define void @f(i32* %A, i32* %B) {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %exitcond = icmp ne i64 %indvars.iv, 3000
  br i1 %exitcond, label %A.must.write.20, label %for.end

A.must.write.20:
  %arrayidx = getelementptr inbounds i32, i32* %A, i64 %indvars.iv
  store i32 20, i32* %arrayidx, align 4
  br label %compute.i.square

compute.i.square:
  %tmp = mul nsw i64 %indvars.iv, %indvars.iv
  %tmp2 = trunc i64 %tmp to i32
  %tobool = icmp eq i32 %tmp2, 0
  br i1 %tobool, label %B.write.from.A, label %A.may.write.90

A.may.write.90:
  %arrayidx2 = getelementptr inbounds i32, i32* %A, i64 %indvars.iv
  store i32 90, i32* %arrayidx2, align 4
  br label %B.write.from.A

B.write.from.A:
  %arrayidx4 = getelementptr inbounds i32, i32* %A, i64 %indvars.iv
  %tmp3 = load i32, i32* %arrayidx4, align 4
  %arrayidx6 = getelementptr inbounds i32, i32* %B, i64 %indvars.iv
  store i32 %tmp3, i32* %arrayidx6, align 4
  br label %A.must.write.42
  ; br label %for.inc

A.must.write.42:
  %arrayidx5 = getelementptr inbounds i32, i32* %A, i64 %indvars.iv
  store i32 42, i32* %arrayidx5, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}
```

##### AST Output for `testbed.ll`

```
if (1 && (&MemRef_A[3000] <= &MemRef_B[0] || &MemRef_B[3000] <= &MemRef_A[0]))

    for (int c0 = 0; c0 <= 2999; c0 += 1) {
      Stmt_compute_i_square__TO__B_write_from_A(c0);
      Stmt_B_write_from_A(c0);
      Stmt_A_must_write_42(c0);
    }

else
    {  /* original code */ }
```

Clearly, this is wrong because the must-write of `A[i] = 20` is not being used even though
this has a side-effect (on the write of `B[i]`).

##### Dependence information for `testbed.ll`

##### Fix
- Make sure that you're actually generating may-writes `:)`.
- Edited `DependenceInfo.cpp` so that may writes work correctly.
- also take may-write info from the flow info that we get.

### Model `must-writes` as `may-writes` for reduction writes, since we need these to always stay, rather than using *transitive closure* in `addPrivatizationDependences()`

- transitive closure is expensive to compure.
- adding may-writes simplifies life by a lot.
- now that may-writes work correctly, this can simplify performance costs.

