# 03/24

## Carry over from yesterday
- Getting all test cases to pass with new WAW & WAR dependence

## Work today
- undersatnd why `WAR = WAR - WAW`.
- Asked tobias. Was apparently change made to use new style of code, but still maintain compatibility with old behaviour (make sure it is `[NFC]`).
- Agrees it needs to be removed.
- Many test cases fail, however. Need to fix this

### Fixing Reduction codegen
- Reduction codegen worked as a side-effect of the way `WAW` dependences were being generated.
- Before, `WAW` only contained `W (sink) <- W (source)`. Things of the form `W(sink) <- .. R <- .. W (source)` were not considered as `WAW`.
- This is an incorrect notion of `WAW`. **However**, when it comes to reductions, we need only these kinds of `WAW`!

```cpp
example-of-strict-WAW.cpp

int reader[100];
int sum = 0;

for(int i = 0; i < 1000; i++) {
S0: 	sum += i;
	
	if (i >= 500 && i <= 600) {
S1:		reader[i - 500] = sum;
	}
}
```

- we have `WAW` between successive S0. 
- **but** between `500 <= i <= 600`, the writes in `S0` thread through the reads in `S1`.
- These are *not* reductions since we cannot freely rearrange them! the values written into `reader` will be different based on our reordering!
- So, when we compute `WAW` **for reuductions**, we need only strict WAW dependences.